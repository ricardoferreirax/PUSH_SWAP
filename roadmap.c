/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   roadmap.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: rickymercury <rickymercury@student.42.f    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/08/17 23:28:21 by rmedeiro          #+#    #+#             */
/*   Updated: 2025/08/29 05:58:04 by rickymercur      ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

Objetivo do push_swap

O push_swap √© um projeto do Common Core da 42 cujo objetivo principal √©:

  - Ordenar uma lista de inteiros, fornecida como argumento ao programa, utilizando apenas duas
    stacks (stack A e stack B) e um conjunto limitado de opera√ß√µes.

    - Temos inicialmente todos os inteiros na stack A, e a stack B come√ßa vazia.
    - Temos de terminar com todos os n√∫meros ordenados em ordem crescente na stack A, e a stack B vazia.
    - As √∫nicas ferramentas que podemos usar s√£o as opera√ß√µes definidas pelo projeto (sa, sb, pa, pb, ra,
      rb, rra, rrb, etc.).
    - O grande desafio n√£o √© s√≥ ordenar, mas faz√™-lo com o menor n√∫mero poss√≠vel de opera√ß√µes.

O que acontece durante a execu√ß√£o ?

    > Parsing e valida√ß√£o: O programa come√ßa por validar os argumentos: n√∫meros v√°lidos, sem duplicados, 
                           dentro do range INT_MIN..INT_MAX.

    > Indexa√ß√£o: Cada n√∫mero √© convertido num √≠ndice de 0 at√© N-1, baseado na sua posi√ß√£o ordenada.
                 Exemplo: [42, -5, 100] ‚Üí √≠ndices [1, 0, 2].
                 Isto simplifica as compara√ß√µes, porque n√£o precisamos de lidar com valores grandes, negativos
                 ou overflow ‚Äî apenas com ‚Äúranks‚Äù.

    > Divis√£o inicial (push para B): Uma parte significativa dos elementos de A √© empurrada para B (normalmente
                                     cerca de metade, escolhidos pelos √≠ndices mais baixos).
                                     Isto reduz o problema e deixa A com poucos elementos (tipicamente 3).

    > Ordena√ß√£o de casos pequenos em A: Se A tiver 2 ou 3 elementos, ordena-se diretamente com swaps e rota√ß√µes 
                                        minimalistas. Isto garante que A j√° est√° ordenada localmente.

    > Reinser√ß√£o inteligente dos elementos de B: De forma iterativa:

        > Para cada elemento em B, calcula-se onde ele deveria entrar em A (posi√ß√£o alvo).
        > Calcula-se o custo da rota√ß√£o em A e B para alinhar tudo.
        > Escolhe-se sempre o elemento com menor custo total.
        > Executam-se rota√ß√µes combinadas (rr ou rrr) para poupar opera√ß√µes.
        > Faz-se pa para mover o elemento para A.

    > Ajuste final: Quando todos os elementos est√£o de volta a A, esta pode n√£o come√ßar no menor √≠ndice.
                    √öltimo passo: rodar A at√© o √≠ndice 0 estar no topo ‚Üí lista final totalmente ordenada.
                    
Algoritmo do meu Push Swap:

    > Turkish (m√©todo turco): - Divide os n√∫meros em blocos (chunks) e empurra para B, por grupos.
                              - Depois traz de volta para A com c√°lculos de posi√ß√£o.

                              - Indexa√ß√£o dos valores para simplificar a manipula√ß√£o.
                              - Push_to_b com crit√©rio de metade ‚Üí mandamoss para B cerca de metade dos elementos 
                                de A (os de menor √≠ndice). Isto √© uma esp√©cie de chunk √∫nico.
                              - Ordena√ß√£o de 3 elementos em A ‚Üí caso base pequeno.
                              - Reinser√ß√£o:
                                
                                    - Calculamos target, cost_a e cost_b.
                                    - Procuramos o elemento de B cujo custo de inser√ß√£o seja mais barato.
                                    - Usamos rota√ß√µes combinadas (rr/rrr) para reduzir opera√ß√µes.
                                    - Repetimos at√© B estar vazio.

                               - Shift final da stack A para alinhar o menor √≠ndice no topo.


Porqu√™ que √© eficiente ? Com a parte do c√°lculo de custos e rota√ß√µes combinadas, chegamoss facilmente dentro dos 
                         limites de opera√ß√µes do projeto:
                          
                         ‚â§ 700 opera√ß√µes para 100 n√∫meros
                         ‚â§ 5500 opera√ß√µes para 500 n√∫meros


No visualizer do push_swap temos: Stack A ‚Üí aparece no lado esquerdo
                                  Stack B ‚Üí aparece no lado direito

No in√≠cio (Count: 0), uma das stacks est√° cheia e a outra completamente vazia.
Essa stack cheia √© a stack A, independentemente de estar √† esquerda ou √† direita no visualizer.

O que acontece no teu algoritmo

    In√≠cio ‚Üí todos os valores est√£o em A (esquerda).
    Push inicial (pb) ‚Üí empurramos metade (ou mais) para B ‚Üí o lado direito come√ßa a encher de barras.
    Ordena√ß√£o em A ‚Üí A fica s√≥ com 3 elementos (caso base), ordenados localmente.
    Reinser√ß√£o (pa) ‚Üí vamos buscar de volta os elementos de B, um a um, e colocamos no s√≠tio certo em A ‚Üí o lado direito
                      esvazia e o esquerdo vai ficando ordenado.

üé® No visualizer

    √â normal e esperado veres as barras a ‚Äúmigrar‚Äù da esquerda para a direita logo no in√≠cio (porque usamos pb).
    Mais tarde, durante a reinser√ß√£o, vais ver o inverso: a stack B esvaziar (direita) e a A organizar-se (esquerda).

POr exemplo, quando iniciamos o push_swap no visualizer, o que observamos no inicio √© o estado inicial da stack A com 500 valores aleat√≥rios:

    > Cada barra horizontal representa um valor.
    > O comprimento e a cor correspondem √† magnitude do n√∫mero (normalmente verde/azul para valores baixos e vermelho/amarelo para valores altos).
    > Como ainda n√£o executamos nenhuma opera√ß√£o (Count: 0 est√° a zero), a stack A aparece toda embaralhada.

Quando carregarmos em Start, o visualizer vai aplicar os comandos gerados pelo push_swap e as barras v√£o-se mover.

O que se v√™ no ecr√£

    Direita ‚Üí Stack B (v√™-se cheia, em degrad√™ do azul at√© vermelho).
    Esquerda ‚Üí Stack A (ainda tem bastantes valores, mas divididos em blocos de cores).
    Comandos (em baixo √† direita) ‚Üí sequ√™ncia de opera√ß√µes que o teu programa est√° a executar (rrb, pa, ra, ‚Ä¶).
    Count: 4775 ‚Üí at√© esse frame j√° foram feitas ~4775 opera√ß√µes.

O que o algoritmo est√° a fazer aqui

    Push inicial para B

        No teu algoritmo, empurras cerca de metade dos n√∫meros (os de menor √≠ndice) para B.

        √â por isso que B est√° quase cheia no lado esquerdo.

    Ordena√ß√£o dos 3 restantes em A

        A fica com 3 elementos, que j√° s√£o ordenados diretamente (sa, ra, rra).

        Isso j√° aconteceu mais acima no processo.

    Reinser√ß√£o gulosa dos elementos de B em A

        Agora o programa est√° a calcular para cada elemento em B onde ele deve entrar em A, e a mover.

        Os comandos que v√™s (rrb, pa, ra, etc.) s√£o exatamente isso:

            rrb ‚Üí roda B para alinhar o pr√≥ximo elemento.

            pa ‚Üí move esse elemento para A.

            ra ‚Üí roda A para colocar esse elemento na posi√ß√£o certa.

    Visualmente

        √Ä esquerda (B), as barras v√£o-se movendo at√© irem todas parar em A.

        √Ä direita (A), come√ßa a formar-se o degrad√™ cont√≠nuo (ordenado).

        No final, A vai estar do azul (valores mais pequenos) no topo ‚Üí at√© ao vermelho (maiores) no fundo.

        B ficar√° vazia.

üìä Em resumo

O que est√°s a ver √© a fase de reinser√ß√£o do algoritmo Turkish Greedy que implementaste:

    B cheio (com os elementos de √≠ndices mais baixos).

    A ainda n√£o ordenado mas com 3 elementos j√° fixos.

    O programa est√° a escolher sempre o elemento de B cujo custo de inser√ß√£o √© menor, depois:

        faz rota√ß√µes (rrb, ra) para alinhar,

        move (pa),

        e repete.

No fim do processo:
‚úÖ B fica vazio,
‚úÖ A fica totalmente ordenado,
‚úÖ o contador mostra o n¬∫ total de opera√ß√µes.



No final, se o algoritmo estiver correto, vais ver as barras alinhadas de cima para baixo em degrad√© suave, ou seja, ordenadas.




typedef struct s_stack {
	int   value;    // valor original (int)
	int   index;    // rank 0..N-1 ap√≥s indexa√ß√£o (min->0, max->N-1)
	int   pos;      // posi√ß√£o atual na stack (0 = topo). recalculado v√°rias vezes
	int   target;   // posi√ß√£o em A onde este node deve ser inserido
	int   cost_a;   // custo para alinhar A at√© 'target' (sinal indica dire√ß√£o)
	int   cost_b;   // custo para alinhar B at√© 'pos' (sinal indica dire√ß√£o)
	struct s_stack *next;
} t_stack;

1)

int	main(int c, char **args)
{
	t_stack	*stack_a;
	t_stack	*stack_b;
	char	**str;

	str = NULL;
	stack_a = NULL;
	stack_b = NULL;
	if (c > 1)
	{
		str = ft_parsing_stack(args);  (1.1)
		ft_parsing(str);               (1.2)
		ft_fill_stack(str, &stack_a);  (1.3)
		free_arr(str);
		ft_index_stack(stack_a, ft_size(stack_a)); (1.4)
		ft_push_swap(&stack_a, &stack_b, ft_size(stack_a));  (1.5)
		ft_free_stack(&stack_a);  (1.6)
		ft_free_stack(&stack_b);
	}
	return (0);
}


a) t_stack *stack_a; e t_stack *stack_b;

    t_stack √© um node de uma linked list.
    Linked list = v√°rios nodes encadeados -> cada node guarda dados e um ponteiro para o pr√≥ximo node.

    Uma linked list √© uma estrutura de dados din√¢mica onde cada elemento (node) guarda os dados (no caso
    do push_swap guarda o value, o index, o target e outros campos) e guarda um ponteiro para o pr√≥ximo node 
    na lista.

    Uma linked list √© diferente de um array: Num array, os elementos est√£o todos seguidos em mem√≥ria.
                                             Numa linked list, cada node pode estar em qualquer s√≠tio da mem√≥ria,
                                             mas est√£o encadeados pelos ponteiros.

    No push swap, o node √© representado pela struct s_stack.

    Tipo: t_stack √© o node da linked list (representa a minha stack).

    typedef struct s_stack 
    {
        int   value;    // o n√∫mero original do input (ex: 42)
        int   index;    // a posi√ß√£o ordenada (rank 0..N-1)
        int   pos;      // posi√ß√£o atual na stack (0 √© o head)
        int   target;   // para onde dever√° ir em A
        int   cost_a;   // custo de rodar A at√© target
        int   cost_b;   // custo de rodar B at√© o node
        struct s_stack *next; // aponta para o pr√≥ximo node
    }   t_stack;

    Visualmente, cada node √© uma esp√©cie de "caixa":

              NODE (T_STACK) 
     -------------------------------
    | value | index | ... | next -> |
     -------------------------------

    > O next aponta para o pr√≥ximo node.
    > Se for o √∫ltimo node, next = NULL.

    Cada node tem:

        - value (o inteiro original),
        - index (rank 0..N-1 ap√≥s indexa√ß√£o),
        - pos, target, cost_a, cost_b (usados durante o algoritmo),
        - next (aponta para o pr√≥ximo node).

    Como cada t_stack representa um node ?

    Cada n√∫mero do input transforma-se num node (t_stack) com: > value = n√∫mero original
                                                               > index = ordem relativa ap√≥s a indexa√ß√£o
                                                               > outros campos (pos, target, cost_a, cost_b) 
                                                                 v√£o sendo calculados durante o algoritmo

    E todos os nodes s√£o ligados com next:

    stack_a ‚îÄ‚îÄ‚ñ∫ [ value=4, index=2 ] ‚îÄ‚îÄ‚ñ∫ [ value=-1, index=0 ] ‚îÄ‚îÄ‚ñ∫ [ value=100, index=5 ] ‚îÄ‚îÄ‚ñ∫ NULL

    O que √© o head ?

    O head √© o primeiro node da lista.
    √â ele que guardamos em stack_a ou stack_b.
    Em contexto da stack, √© sempre na head que as opera√ß√µes atuam (pa, pb, sa, etc).

    Visualiza√ß√£o de 3 nodes na stack (head √† esquerda):

    [head] -> [value=3]->[value=10]->[value=7]->NULL
                 ^           ^           ^
               node0       node1       node2

    Aqui o head aponta para o node com value=3, ou seja, para o node0. Esse node aponta para o pr√≥ximo (node1) e assim por diante.

    O que √© o tail ?

    O tail √© o √∫ltimo node da lista.
    √â aquele cujo next = NULL.
    
    No exemplo acima, o nosso tail √© o node2, com value=7, porque depois dele n√£o h√° mais nada.
    

    Assim, temos que: > t_stack *stack_a: √â um ponteiro que aponta para o head da pilha A, ou seja, aponta para
                                          o primeiro node da stack A. Caso esteja vazia, aponta para NULL.
                                     
                      > t_stack *stack_b: √â um ponteiro que aponta para o head da pilha B, ou seja, aponta para 
                                          o primeiro node da stack B. Caso esteja vazia, aponta para NULL.

    Porque s√£o pointers ? As opera√ß√µes (ex.: pa, pb, ra, rra, ‚Ä¶) alteram o head da stack. Em C, para
    uma fun√ß√£o poder alterar o head, passamos o endere√ßo do ponteiro (t_stack **), e dentro da fun√ß√£o
    ele pode fazer, por exemplo, *stack = (*stack)->next, etc.

    Inicializar a NULL:

        - Estado inicial v√°lido e expl√≠cito: A e B come√ßam vazias.
        - Permite verifica√ß√µes simples (if (!stack) ...).
        - Torna seguro chamar fun√ß√µes que libertam/consultam a stack.
        - Em caso de erro precoce, n√£o corres o risco de fazer free num lixo.

    Ciclo de vida:

        - S√£o preenchidas em ft_fill_stack (a stack A fica com todos os nodes).
        - Durante o algoritmo, pb/pa movem os nodes entre as stacks A e B (ajustando estes ponteiros).
        - No fim, ft_free_stack(&stack_a) e ft_free_stack(&stack_b) libertam tudo.

b) char **str;

    Antes de criarmos a linked list, precisamos de ler os n√∫meros em texto (string) da linha de comandos do terminal (argv).
    
    Por exemplo, o input pode ser:  ./push_swap "3 2 1"

    Primeiro transformamos tudo numa string √∫nica e depois fazemos split em espa√ßos (' ').

    argv = {"./push_swap", "3", "2", "1", NULL}

    Ficamos com: ft_parsing_stack(argv) ‚Üí ft_split ‚Üí {"3", "2", "1", NULL}

    Em que: str[0] = "3"
            str[1] = "2"
            str[2] = "1"
            str[3] = NULL

    Tipo: √â um array de strings (cada elemento √© char * terminado em '\0').

    Significado no projeto: √â a forma normalizada dos argumentos da linha de comandos.

        > Em ft_parsing_stack(args): - juntamos todos os argv[1..] numa √∫nica string com espa√ßos,
                                     - fazemos ft_split(..., ' '),
                                     - ficamos com str = {"123", "-4", "42", NULL}.

    Porque str = NULL no arranque? 
    
    > Estado inicial seguro: Logo ao arrancar o programa, ainda n√£o temos str alocada. Ao colocar str = NULL, estamos a dizer
                             algo como "ainda n√£o temos nenhuma string alocada, est√° vazio".
    > Defensive programming: Se houver erro antes de preenchermos (alocarmos) str, e fizermos free_arr(str), a fun√ß√£o vai ver 
                             str = NULL e simplesmente n√£o faz nada, ou seja, n√£o h√° tentativa de libertar mem√≥ria n√£o alocada.

    Como isso se encaixa no fluxo do main?

    Arranque seguro

    str = NULL;      // ainda n√£o temos strings
    stack_a = NULL;  // A vazia
    stack_b = NULL;  // B vazia

    Se c > 1 (houver argumentos): > str = ft_parsing_stack(args); ‚Üí aloca e preenche str, criando, por exemplo, str = {"123", "-4", "42", NULL}.
                                  > ft_parsing(str); ‚Üí valida o formato e duplicados.
                                  > ft_fill_stack(str, &stack_a); ‚Üí cria os nodes e liga-os (√© criada uma linked list); a stack_a deixa de ser NULL.
                                  > free_arr(str); ‚Üí libertamos as strings (j√° n√£o precisamos).


1.1) str = ft_parsing_stack(args)

char	**ft_parsing_stack(char **args)
{
	char	**str;
	char	*s;

	s = NULL;
	s = ft_join_args(args);  (1.1.1)   // primeiro junta os argumentos numa √∫nica string
	str = ft_split(s, ' ');  (1.1.2)  // divide essa string em v√°rios n√∫meros
	free(s);                         // liberta a string tempor√°ria
	return (str);                   // devolve os n√∫meros em texto
}


Independentemente como o utilizador escreve os n√∫meros na linha de comandos do terminal (com aspas, com v√°rios espa√ßos, separados ou juntos),
queremos sempre acabar com um array de "palavras" onde cada palavra √© um n√∫mero em formato de texto.

    Ex.: ./push_swap 3 2 1
    Ex.: ./push_swap "3 2 1"
    Ex.: ./push_swap " 3" 2 "1 "

Todos estes casos devem resultar num array de palavras assim: str = {"3", "2", "1", NULL}

1.1.1) s = ft_join_args(args); 

args √© o argv do main, onde args[0] √© o nome do programa.

Vejamos:

static char *ft_join_args(char **args)
{
    char *tmp;
    int   i;

    i = 1;                  // come√ßa em 1 pois ignora argv[0] (nome do programa)
    tmp = ft_strdup("");    // come√ßa com string vazia
    if (!tmp)
    {
        ft_error();
        exit(1);
    }
    while (args[i])
    {
        if (ft_has_only_spaces(args[i]))  // se forem "s√≥ espa√ßos", rejeita esses argumentos
        {
            ft_error();
            free(tmp);
            exit(1);
        }
        tmp = ft_strjoin(tmp, args[i]);  // junta o argumento atual
        if (!tmp)
        {
            ft_error();
            exit(1);
        }
        tmp = ft_strjoin(tmp, " ");
        if (!tmp)
        {
            ft_error();
            exit(1);
        }
        i++;
    }
    return tmp;
}

[a] if (ft_has_only_spaces(args[i]))

static int	ft_has_only_spaces(char *s)
{
	int	i;

	i = 0;
	while (s[i] == ' ')
		i++;
	if (s[i] == '\0')
		return (1);
	return (0);
}

O que √© que a fun√ß√£o ft_join_args() faz ?

    - Pega nos argumentos da linha de comandos do terminal (argv) a partir do argv[1] (ignorando o args[0]) constr√≥i/concatena
      tudo numa √∫nica string com todos os argumentos (n√∫meros args[1], args[2], ...), separados por um espa√ßo.
    - Valida ‚Äús√≥ espa√ßos‚Äù por argumento com a fun√ß√£o ft_has_only_spaces() e, se acontecer, chama ft_error() e termina 
      (evita criarmos palavras vazias).
    - Garante um espa√ßo entre cada argumento (facilita o split a seguir).  
   
    Linha: tmp = ft_strdup("");

    ft_strdup duplica a string (aloca mem√≥ria e copia os caracteres).
    Aqui duplicamos "", ou seja, uma string vazia (s√≥ cont√©m '\0').

    Resultado: √â alocada mem√≥ria para 1 caracter ('\0').
               tmp passa a apontar para "" (string vazia).

    Garante que tmp √© sempre uma string v√°lida desde o in√≠cio.
    D√° seguran√ßa porque tmp pode ser libertado sempre que precisarmos, mesmo que n√£o tenhamoss concatenado nada ainda.

    Isto significa que come√ßamos com uma base segura sobre a qual podemos concatenar (ft_strjoin) logo de seguida.

    Linha: tmp = ft_strjoin(tmp, args[i]);

    Junta o conte√∫do acumulado (tmp) com o argumento atual (args[i]).

    A ft_strjoin: - Cria a nova string com espa√ßo para len(s1) + len(s2) + 1.
                  - Copia s1 + s2.
                  - D√° free(s1) automaticamente.
                  - Retorna a nova string.

    Por isso: O tmp antigo √© libertado dentro do ft_strjoin.
              O tmp passa a apontar para a nova string concatenada.

    Linha: tmp = ft_strjoin(tmp, " ");

    Agora que j√° juntamos o argumento, vamos acrescentar um espa√ßo de modo a que o pr√≥ximo n√∫mero n√£o fique colado 
    ao anterior. Serve para separar os pr√≥ximos argumentos quando fizermos split.

    Exemplo: Depois do primeiro argumento "42" ‚Üí "42 ".
             Depois do segundo "7" ‚Üí "42 7 ".
             Depois do terceiro "-3" ‚Üí "42 7 -3 ".

    No fim temos uma √∫nica string com tudo concatenado e separado por espa√ßos.

    Exemplo1:  ./push_swap 3 2 1

    Antes do loop: tmp = ft_strdup(""); ‚Üí "" (string vazia).

    Itera√ß√£o 1: tmp = ft_strjoin("", "3"); ‚Üí "3".
                tmp = ft_strjoin("3", " "); ‚Üí "3 ".

    Itera√ß√£o 2: tmp = ft_strjoin("3 ", "2"); ‚Üí "3 2".
                tmp = ft_strjoin("3 2", " "); ‚Üí "3 2 ".

    Itera√ß√£o 3: tmp = ft_strjoin("3 2 ", "1"); ‚Üí "3 2 1".
                tmp = ft_strjoin("3 2 1", " "); ‚Üí "3 2 1 ".

    No fim: tmp = "3 2 1 ".

    
    Exemplo2:

    Juntamos tudo o que o utilizador escreveu (menos o nome do programa).

    Ex.: Para ./push_swap 3 2 1
              
    args = {"./push_swap", "3", "2", "1", NULL}
    ft_join_args(args) ‚Üí s = "3 2 1 "

    Ex.: Para ./push_swap " 3" 2 "1 "

    args = {"./push_swap", "  3", "2   1", NULL}
    ft_join_args(args) ‚Üí s = "  3 2   1 "


1.1.2) str = ft_split(s, ' '); 

    Agora, pegamos na string s (que a fun√ß√£o ft_join_args() construiu) e dividimos em v√°rias palavras, utilizando
    o espa√ßo ' ' como separador. 
    O resultado √© um array em que cada c√©lula √© uma ‚Äúpalavra‚Äù (n√∫mero em texto).

    Exemplo A: s = "3 2 1 "
               ft_split(s, ' ') ‚Üí str = {"3","2","1", NULL}

    Exemplo B: s = "  3 2   1 "
               ft_split(s, ' ') ‚Üí str = {"3","2","1", NULL}

    (ft_split normalmente ignora m√∫ltiplos espa√ßos ‚Äî n√£o cria palavras vazias)

    Cada n√∫mero que estava misturado numa frase s√≥, agora vira uma string separada no array str.

    Porque √© importante? No push_swap, n√£o podemoss trabalhar diretamente com a string "3 2 1 ".
    
    Temos de ter cada n√∫mero isolado ("3", "2", "1") para depois: - verificar se s√£o v√°lidos (ft_parsing(str)),
                                                                  - converter em inteiros (ft_fill_stack).

    A fun√ß√£o free(s) liberta a string tempor√°ria s que j√° n√£o precisamos.
    Depois de termos dividido em str, podemos libertar (free(s)), porque toda a informa√ß√£o que interessa agora est√° em str.
    Isto √© importante para n√£o deixar memory leaks.
    Se n√£o libertassemos, ficariamos com mem√≥ria perdida, porque nunca mais vamos us√°-la.

    Por fim, devolvemos o array str (return (str)).

    Voltando √† main, str = ft_parsing_stack(args) agora guarda a forma normalizada do input: com cada n√∫mero separado como
    uma string num array, terminado em NULL. 
    O que significa que transformamos os argumentos da linha de comandos num array
    de strings onde cada string √© um n√∫mero separado.

 
1.2) ft_parsing(str); 

void	ft_parsing(char **args)
{
	if (!ft_valid_args(args))  [a]
	{
		free_arr(args);
		ft_error();
		exit(1);
	}
	if (!ft_is_duplicated(args))  [b]
	{
		free_arr(args);
		ft_error();
		exit(1);
	}
}

Depois de str = ft_parsing_stack(args); temos str como um array de strings, por ex.: {"3", "2", "1", NULL}

Chamamos ft_parsing(str) para garantir que o formato de cada palavra (n√∫mero em texto) √© v√°lido e se n√£o existem n√∫meros repetidos
(numericamente iguais).

Primeiro verificamos se os argumentos s√£o v√°lidos: 

[a] if (!ft_valid_args(args)) 

static int	ft_valid_args(char **args)
{
	int	i;
	int	j;

	i = 0;
	while (args[i])  // enquanto houver argumentos
	{
		j = 0;
		if (ft_is_signed(args[i][j]))  // verificar se na primeira posi√ß√£o est√° o sinal '+' ou '-'
		{
			if (!args[i][j + 1])  // verificar se s√≥ tem sinal sem n√∫mero (o que √© inv√°lido)
				return (0);
			j++;
		}
		while (args[i][j])  // Percorremos a string caracter a caracter
		{
			if (!ft_is_digit(args[i][j]))  // Verificamos se √© digito. Qualquer argumento n√£o num√©rico √© inv√°lido
				return (0);
			j++;
		}
		i++;
	}
	return (1);
}


> A fun√ß√£o ft_valid_args(args) valida a forma textual de cada string (args[i]) (a string √© o array que veio da fun√ß√£o
  ft_parsing_stack() e foi criado pela fun√ß√£o ft_split()).

> args[i] √© uma das strings que veio do ft_split, ou seja, um dos n√∫meros de input.

> if (ft_is_signed(args[i][j]))  // verifica se na primeira posi√ß√£o est√° o sinal '+' ou '-'

  ft_is_signed(args[i][j]) verifica se o primeiro car√°cter √© '+' ou '-'.

  Exemplo: args[i] = "-42" ‚Üí args[i][0] = '-' ‚Üí ft_is_signed('-') = true.

           args[i] = "123" ‚Üí args[i][0] = '1' ‚Üí n√£o √© sinal, logo false.

> Se houver sinal, ou seja, se o primeiro car√°cter for sinal (+ ou -), verificamos se
  existe algum car√°cter a seguir ao sinal -> if (!args[i][j + 1]) 

  Se n√£o existir (ou seja, se for '\0' ‚Üí fim da string), significa que o argumento era s√≥ "+" ou "-".
  Isso √© inv√°lido ‚Üí porque n√£o h√° n√∫mero nenhum.
  Ent√£o return (0); ‚Üí invalida o argumento.

> Se havia sinal e tamb√©m h√° mais caracteres depois dele, avan√ßamos o √≠ndice j (j++) para come√ßar a 
  verificar a partir do primeiro d√≠gito.

  Exemplo: args[i] = "-42"

           args[i][0] = '-' ‚Üí sinal.

           args[i][1] = '4' ‚Üí existe algo depois.

           Fazemos j++, ent√£o agora vamos come√ßar a verificar a partir do '4'.
           
> j √© o indice dentro da string args[i] -> args[i][j].
  Se havia sinal, come√ßamos em j = 1.
  Se n√£o havua sinal, come√ßamos em j = 0.

> while (args[i][j]) percorre a string caracter a caracter at√© chegar ao fim da string.

> if (!ft_is_digit(args[i][j])) verifica se o car√°cter atual √© um d√≠gito (0 a 9).
  
  Se n√£o for, retorna 0 ‚Üí inv√°lido.
  Isso elimina coisas como: "12a" (porque 'a' n√£o √© d√≠gito).
                            "3.14" (o '.' reprova).
                            " 42" (o espa√ßo reprova, mas na pr√°tica espa√ßos j√° tinham sido tratados pelo split).
                            
> Se for digito, avan√ßa para o pr√≥ximo caracter (j++).

> Quando terminarmos de validar a string inteira (args[i]), passamos para o pr√≥ximo argumento (i++).
  O while exterior - while (args[i]) - repete o mesmo processo para todas as strings.

> Por fim, se todos os argumentos tiverem um formato v√°lido, a fun√ß√£o retorna 1.

O que garante no fim ?

Depois deste loop: - Cada string (args[i]) foi confirmada como n√∫mero inteiro v√°lido.
                   - Portanto, no fim de ft_valid_args, todos os elementos de args s√£o strings compostas s√≥ por 
                     d√≠gitos (com sinal opcional no in√≠cio).

                     
O que isto permite: "123", "-7", "+42", "0005", "-0" ‚Üí v√°lidos
                    Um sinal s√≥ no in√≠cio, e ao menos um d√≠gito a seguir.

O que reprova (exemplos): "" (string vazia)
                          "3.14"
                          "+" ou "-" (sinal sem d√≠gitos)
                          "12a", "--1", "+-3"
                          " 3" (espa√ßos dentro da palavra)
                          "3 2" dentro do mesmo elemento (sem aspas no shell)

Nota: espa√ßos a mais foram resolvidos antes (no split). Se o utilizador p√¥s tabs ou outros caracteres
      dentro das aspas, aqui v√£o reprovar por n√£o serem d√≠gitos.

      
Depois de verificarmos com a fun√ß√£o ft_valid_args(args):

if (!ft_valid_args(args))
	{
		free_arr(args);
		ft_error();
		exit(1);
	}

Verificamos se alguma das strings n√£o cumprem com as regras impostas pela fun√ß√£o ft_valid_args(), ou seja, se ap√≥s o sinal 
(se existir) todos os caracteres n√£o forem digitos, √© libertada a mem√≥ria do array de strings (args), chama a fun√ß√£o
ft_error() para imprimir a mensagem de erro e termina imediatamente o programa com o c√≥digo de sa√≠da 1.

Porque libertamos antes de sair? 

args (isto √©, str) foi alocado na fun√ß√£o ft_parsing_stack().
Se for inv√°lido, n√£o voltamos √† main para n√£o vazar mem√≥ria, pelo o que libertamos antes de sair com exit(1).

> if (!ft_is_duplicated(args)): Caso as strings cumpram as regras impostas pela fun√ß√£o ft_valid_args(), verificamos se h√° 
  n√∫meros que se repetem, pois no push swap, a stack inicial n√£o pode ter n√∫meros repetidos (duplicados).

  Por exemplo: ./push_swap 3 5 2 5

               Aqui o 5 aparece duas vezes, o que torna o input inv√°lido.
    
[b]

int	ft_is_duplicated(char **args)
{
	int	i;
	int	j;

	i = 0;
	while (args[i])  // Percorre cada argumento (cada n√∫mero)
	{
		j = i + 1;
		while (args[j])
		{
			if (ft_atoi(args[i]) == ft_atoi(args[j]))  // compara args[i] com os seguintes
				return (0);   // se encontrou dois n√∫meros iguais (duplicados) retorna 0 pois √© inv√°lido
			j++;  // Se n√£o encontrou duplicados, incrementa para o argumento seguinte e compara com args[i]
		}
		i++; // se o argumento args[i] n√£o √© igual a nenhum args[j], avan√ßa para o pr√≥ximo para continuarmos a verificar os seguintes argumentos
	}
	return (1);  // se percorreu tudo sem encontrar n√∫meros duplicados, retorna 1
}

O objetivo da fun√ß√£o ft_is_duplicated() √© o de garantir que n√£o existem n√∫meros repetidos no input.
Compara o valor num√©rico, n√£o a string em si, ou seja:

  - "1" e "01" ‚Üí ambos d√£o 1 em ft_atoi ‚Üí conta como duplicado.
  - "0" e "-0" ‚Üí ambos d√£o 0 ‚Üí duplicado.

Porque comparamos o valor num√©rico e n√£o as strings?

Duas strings diferentes podem representar o mesmo n√∫mero. Exemplos:

String A	 String B	S√£o o mesmo n√∫mero?	   Comparar como string	           Comparar como n√∫mero
  "1"	       "01"	       Sim (ambas 1)	    diferentes ‚Üí falso negativo	         iguais ‚úÖ
  "0"	       "-0"	       Sim (ambas 0)	    diferentes ‚Üí falso negativo	         iguais ‚úÖ
 "+42"	       "42"	       Sim (ambas 42)	    diferentes ‚Üí falso negativo	         iguais ‚úÖ

Se comparassemos diretamente as strings (ft_strcmp), iriamoss deixar passar duplicados (ex.: "01" e "1").
Quando convertemos para int (ft_atoi), ambas as representa√ß√µes tornam-se no mesmo valor num√©rico ‚Äî e a√≠ o
duplicado √© detetado.

Como a fun√ß√£o ft_is_duplicated() procura os duplicados?

Vejamos, por exemplo, o array de strings args ->  args = {"10", "-3", "10", "00010", NULL}

A fun√ß√£o:

> Come√ßa em i = 0 ‚Üí ou seja, come√ßamos em "10"

> No loop while (args[i]) vamos percorrer cada argumento at√© ao fim.

> Para cada argumento (args[i]), come√ßamos j com o pr√≥ximo elemento (i + 1) -> neste caso j = 1, que corresponde
  a "-3".
  Iniciamos j = i + 1 para assim compararmos args[i] com todos os argumentos seguintes, evitando comparar consigo
  pr√≥prio e evitando comparar o mesmo par duas vezes.

> No loop while (args[j]) vamos percorrer os elementos seguintes ao argumento atual, at√© ao fim.

> if (ft_atoi(args[i]) == ft_atoi(args[j])): Convertemos ambas as strings para um inteiro com ft_atoi e vamos comparar
  os valores num√©ricos.

  i = 0 e j = 1 ‚Üí compara "10" com "-3" ‚Üí 10 != -3 ‚Üí segue
  i = 0 e j = 2 ‚Üí compara "10" com "10" ‚Üí 10 == 10 ‚Üí ENcontrou um duplicado ‚Üí retorna 0 (n√£o continua)

(nem precisamos de ver "00010")-

> Se encontrarmos dois n√∫meros com o mesmo valor num√©rico, o input √© considerado inv√°lido, pois duplicados n√£o s√£o permitidos
  no push swap. A fun√ß√£o termina imediatamente retornando 0.

> Ao chegarmos ao fim sem encontrarmos n√∫meros duplicados, retornamos 1.


At√© aqui j√° fizesmos: > str = ft_parsing_stack(args); ‚Üí temos um array de strings com cada n√∫mero em texto,
                        p.ex: str = {"3","-1","2",NULL}
                      > ft_parsing(str); ‚Üí garantimos que cada string tem formato v√°lido (sinal opcional + d√≠gitos)
                        e n√£o existem repetidos (numericamente).

Falta garantir que cabem num int e transformar estas strings em nodes da stack A. √â exatamente isso que faz ft_fill_stack.

1.3)

void	ft_fill_stack(char **str, t_stack **stack)
{
	long int	value;
	int			i;

	*stack = NULL;  // come√ßa com a stack vazia
	i = 0;
	while (str[i])  // percorre cada string 
	{
		if (ft_valid_number(str[i]) == 1)  [a]
		{
			free_arr(str);
			ft_error();
			ft_free_stack(stack);
			exit(1);
		}
		value = ft_atoi(str[i]); // converte para int
		ft_lst_add_back(stack, ft_lst_new(value));  [b]  // cria o node e liga-o no fim 
		i++;
	}
}


> char **str √© o array de strings que cont√©m cada n√∫mero str = {"3", "-1", "42", NULL};
 
  Ou seja:  str[0] ‚Üí "3"
            str[1] ‚Üí "-1"
            str[2] ‚Üí "42"
            str[3] ‚Üí NULL (fim do array)

> t_stack **stack √© o pointer que aponta para o head da stack. √â double pointer porque queremos modificar o ponteiro original
  da main, e por isso temos de passar o endere√ßo dela -> ft_fill_stack(str, &stack_a);

> long int value √© a vari√°vel onde guardamos cada n√∫mero convertido para inteiro.
  Porqu√™ que √© long int ? O push swap s√≥ permite inteiros de 32 bits (int ‚Üí [-2147483648, 2147483647]), mas ao converter de 
  char * (string) para um n√∫mero (int), precisamos de ter cuidado com o overflow.


> while (str[i]): percorremos as strings (n√∫meros em texto)

  O str vem do ft_split, termina em NULL.
  Vamos tratar de cada string e transform√°-la num node.
  
  Exemplo de input: str = {"3","-1","2",NULL}

> if (ft_valid_number(str[i]) == 1) ‚Äî verifica√ß√£o do range de um int.

[a]

int	ft_valid_number(const char *str)
{
	long	res;
	int		i;
	int		sign;

	res = 0;
	i = 0;
	sign = 1;
	while (str[i] == ' ' || (str[i] >= 9 && str[i] <= 13))
		i++;
	if (str[i] == '+' || str[i] == '-')
	{
		if (str[i] == '-')
			sign *= -1;
		i++;
	}
	while (str[i] >= '0' && str[i] <= '9')
	{
		res = (res * 10) + (str[i] - '0');
		i++;
		if ((res * sign) > 2147483647 || (res * sign) < -2147483648)
			return (1);
	}
	return (0);
}

A fun√ß√£o ft_valid_number() l√™ o n√∫mero acumulando em long e devolve 1 se o valor sair do intervalo do int (INT_MIN..INT_MAX).
Aqui completamos a valida√ß√£o: n√£o aceitamos coisas como "2147483648" ou "-2147483649".

Se for inv√°lido: - free_arr(str); ‚Üí libertamos o array de strings (j√° n√£o vamos us√°-lo).
                 - ft_error(); ‚Üí escrevemos a mensagem Error\n.
                 - ft_free_stack(stack); ‚Üí se j√° tinhamos criado alguns nodes, libertamos para n√£o haver leaks.
                 - exit(1); ‚Üí aborta e sai.

Ap√≥s passar pela valida√ß√£o:

> COnvertemos a string para um inteiro (convertemos para o seu valor num√©rico) -> value = ft_atoi(str[i])

  str[i] = "0005" ‚Üí value = 5
  str[i] = "-0" ‚Üí value = 0
  str[i] = "+42" ‚Üí value = 42

> Criamos e anexamos o node -> ft_lst_add_back(stack, ft_lst_new(value))

    > ft_lst_new(value)

    [b]
    t_stack	*ft_lst_new(int value)
    {
	    t_stack	*new;

	    new = malloc(sizeof(t_stack));
	    if (!new)
		    return (NULL);
	    new->value = value;  // n√∫mero inteiro original que l√™mos do input
	    new->index = 0;      // ainda n√£o indexado (vai receber 0 a n - 1 na fun√ß√£o ft_index_stack())
	    new->pos = -1;       // posi√ß√£o atual do node na stack (0 = topo) - ainda n√£o calculada - s√≥ √© valido em ft_position()
	    new->target = -1;    // posi√ß√£o alvo na stack A onde este node (vindo de B) deve ser inserido para manter A ordenada - ainda n√£o calculada
	    new->cost_a = -1;    // custo do n√∫mero de rota√ß√µes que temos de fazer em A para alinhar o target e trazer o node para o topo - ainda n√£o calculada - ft_cost
	    new->cost_b = -1;    // custo do n√∫mero de rota√ß√µes que temos de fazer em B para alinhar o target at√© o node - ainda n√£o calculada
	    new->next = NULL;    // √© o ponteiro para o pr√≥ximo node da linked list - incialmente ainda n√£o est√° ligado a nenhum node
	    return (new);
    }

    Aloca um t_stack (node) e preenche os campos iniciais:

        - node->value = value;
        - node->index = 0 (ainda n√£o indexado. Ser√° preenchido na fun√ß√£o ft_index_stack()).
          Ap√≥s a fun√ß√£o ft_index_stack(), o menor valor ter√° index = 0 e o maior index = n - 1.
          Inicialmente utilizamos index = 0 como "ainda n√£o indexado".
        - node->pos = node->target = node->cost_a = node->cost_b = -1; (valores ‚Äún√£o calculados‚Äù)
        - node->next = NULL;

        
    > ft_lst_add_back(stack, ft_lst_new(value))

    void	ft_lst_add_back(t_stack **stack, t_stack *new)
    {
	    t_stack	*last;  // ponteiro que aponta para o √∫ltimo node atual da lista -> guarda o endere√ßo do tail

	    if (!new)   // se a cria√ß√£o do node falhou
		    return ;  // n√£o fazemos nada
	    if (!*stack)  // Se a linked list estiver vazia, n√£o h√° fim para procurar (o novo node ser√° o primeiro)
	    {
		    *stack = new;  // altera o head, e o novo node torna-se o head
		    return ;  // terminamos
	    }
	    last = ft_last(*stack);  // Percorremos a lista at√© encontramos o √∫ltimo node (tail) e guardamos em last
	    last->next = new;        // ligamos o novo node ao fim da lista
    }

    A fun√ß√£o ft_lst_add_back() anexa o novo node ao fim (tail) da linked list, cujo o head √© o *stack.

    Pensemos na linked list como uma fila de caixas ligadas por setas:  head ‚îÄ‚îÄ‚ñ∫ [3] ‚îÄ‚îÄ‚ñ∫ [-1] ‚îÄ‚îÄ‚ñ∫ [2] ‚îÄ‚îÄ‚ñ∫ NULL

    Queremos p√¥r a nova caixa [7] no fim:  head ‚îÄ‚îÄ‚ñ∫ [3] ‚îÄ‚îÄ‚ñ∫ [-1] ‚îÄ‚îÄ‚ñ∫ [2] ‚îÄ‚îÄ‚ñ∫ [7] ‚îÄ‚îÄ‚ñ∫ NULL

    
    Por que t_stack **stack (ponteiro para ponteiro) ?
    
    > *stack √© ponteiro que aponta para o primeiro node (√© o head da lista).
    > √Äs vezes precisamos de alterar o head, por exemplo, quando a lista est√° vazia (*stack == NULL) e precisamos de anexar
      o primeiro node. 
      Assim, para anexar o primeiro node temos de alterar o head de NULL para o novo node.
    > Para uma fun√ß√£o conseguir modificar a vari√°vel do chamador (o head), temos de receber o endere√ßo dessa vari√°vel -> t_stack ** .
    > Se fosse t_stack *stack (uma c√≥pia), dentro da fun√ß√£o faziamos stack = new mas o chamador n√£o veria a mudan√ßa, estavamos a
      mudar s√≥ a c√≥pia local.
      Assim, como dentro da fun√ß√£o fazemos *stack = new, se fizemos sem o ** (se fosse t_stack *stack) alteravamos apenas uma c√≥pia local 
      do ponteiro, e o chamador n√£o veria a mudan√ßa.

    O que representa a t_stack *last ?

    > √â um ponteiro tempor√°rio que aponta para o √∫ltimo node atual da lista, antes de anexarmos o novo.
    > √â utilizado para chegarmos ao √∫ltimo node da lista (o tail) sem perder o head.
    > Se fizessemos *stack = (*stack)->next para andar pela lista, perderiamos o head.
      Ao usar um ponteiro tempor√°rio, podemos percorrer a lista √† vontade.
    > Serve, assim, para conseguirmos fazer last->next = new sem perdermos o head.
    

    O que ft_lst_add_back faz :

    > Lista vazia ? (*stack == NULL) ‚Üí Quando a lista est√° vazia, n√£o h√° fim para procurar: o novo node ser√° o primeiro, passando, assim,
      a ser o head - *stack = new - alteramos assim o head do chamador (por isso precisamos de t_stack **).
      Depois disto, a lista fica: head -> [new] -> NULL.

      Exemplo: *stack = NULL
               new = [7] -> NULL

      if (!*stack) ‚Üí √© verdade
        *stack = new;
    
      Depois:   *stack ‚îÄ‚îÄ‚ñ∫ [7] -> NULL  (head passou a ser [7])

      
    > Caso contr√°rio, percorremos a lista a partir do head at√© encontrar o node cujo next == NULL. 

      t_stack	*ft_last(t_stack *stack)
      {
	    while (stack && stack->next)  // percorre a lista enquanto houver pr√≥ximo (stack->next)
		    stack = stack->next;
	    return (stack);    // retorna o primeiro com next == NULL (que √© o tail)
      }

      Exemplo: stack = [3] -> [-1] -> [2] -> NULL

               loop:

                stack = [3], stack->next existe ‚Üí stack = [-1]
                stack = [-1], stack->next existe ‚Üí stack = [2]
                stack = [2], stack->next == NULL ‚Üí sai
                
                return [2]

      Exemplo:  Antes: *stack ‚îÄ‚îÄ‚ñ∫ [3] -> NULL
                        new = [7] -> NULL

                if (!*stack) ‚Üí falso

                last = ft_last(*stack) ‚Üí last = [3]
                last->next = new;
                
                Depois:  *stack ‚îÄ‚îÄ‚ñ∫ [3] -> [7] -> NULL

      Encontramos o √∫ltimo node (ft_last) e ligamos o novo node ao fim: last->next = new;

      
    Antes:  *stack -> [3] -> [-1] -> [2] -> NULL     Depois: *stack -> [3] -> [-1] -> [2] -> [7] -> NULL
        
            new: [7] -> NULL


    
1.4) ft_index_stack(stack_a, ft_size(stack_a))

void	ft_index_stack(t_stack *stack_a, int size)
{
	t_stack *current;       // ponteiro para percorrer a lista
	t_stack *high_node;      // ponteiro para guardar o endere√ßo do node que cont√©m o maior valor encontrado at√© agora (maior node ainda sem √≠ndice).
	int      max_val;       // guarda o maior valor atual visto 

	while (size-- > 0)   // percorre N vezes (N = tamanho da lista ou seja, N = n√∫mero de nodes)
	{
		current = stack_a;  // recome√ßa no √≠nicio da lista
		high_node = NULL;    // ainda n√£o escolhemos o maior node atual desta itera√ß√£o
		max_val = INT_MIN;  // o maior valor visto come√ßa no minimo possivel
		while (current)     // percorre a lista inteira
		{
            // s√≥ nos interessa os nodes que ainda n√£o t√™m indice atribuido
			if (current->index == 0 && current->value >= max_val)
			{
				max_val = current->value;   // atualizamos o maior valor visto
				high_node = current;         // guarda o endere√ßo desse node
			}
			current = current->next;  // avan√ßamos na lista para o pr√≥ximo node
		}
		if (high_node)  // ao percorrermos a lista, se "max_node" √© o maior ainda sem indice
			high_node->index = size;  // atribuimos o indice atual (descrescente)
	}
}

Esta fun√ß√£o atribui um √≠ndice ordenado a cada node da lista stack_a, de modo a que cada node
passa a ter um indice de 0 a N-1 (0 = menor valor da lista, N-1 = maior valor da lista e os restantes valores
ficam no meio por ordem crescente).
Tabalhar com estes indices √© muito mais simples no push swap do que utilizar os valores reais (que podem ser 
negativos, muito grandes, etc), Depois disto, quase tudo no algoritmo do push swap compara indices.

A fun√ß√£o faz uma esp√©cie de selection sort de m√°ximos: em cada itera√ß√£o escolhemos o maior node que ainda n√£o
tem √≠ndice e damos-lhe o maior √≠ndice dispon√≠vel.
O while (size-- > 0) faz com que os √≠ndices atribu√≠dos sejam: N-1, N-2, ..., 0 (nesta ordem).
Como todos os nodes come√ßam com index = 0, cada vez que ‚Äúmarcamos‚Äù um node com outro valor (>0), ele deixa de 
ser considerado nas itera√ß√µes seguintes.
No fim, vai sobrar exatamente um node com index == 0: o menor da lista (√© isso mesmo que queremos).

Por que index == 0 significa ‚Äúainda n√£o indexado‚Äù?

> Em ft_lst_new metemos index = 0 por defeito.
> Nesta fun√ß√£o, cada vez que escolhemos um node, mudamos-lhe o index de 0 para N-1, depois N-2, ‚Ä¶
> O √∫ltimo node que sobrar sem ser "marcado" (continua 0) √© precisamente o menor valor, que no fim deve mesmo 
  ter index = 0.

Exemplo: Suponhamos que a lista tem estes value (na ordem em que foram lidos) e size = 4:

         stack_a:  [  40 ] ‚Üí [  -5 ] ‚Üí [ 12 ] ‚Üí [ 7 ] ‚Üí NULL
           index:     0         0        0        0


> stack_a: head da lista com todos os n√≥s j√° criados na fun√ß√£o ft_fill_stack().
> size: tamanho atual da lista (usa ft_size(stack_a) ao chamar).
> current: ponteiro para percorrer a lista do √≠nicio ao fim.
> max_node: ponteiro para guardar o endere√ßo do node que cont√©m o maior valor encontrado at√© agora (maior node ainda sem √≠ndice).
> max_val: valor do ‚Äúmaior valor encontrado at√© agora‚Äù nesta itera√ß√£o. Serve de referencia para comparar cada node da lista.

Loop while(size-- > 0)

> Este loop executa exatamente N itera√ß√µes (N = n√∫mero de nodes).
> A cada itera√ß√£o √© escolhido o node com o maior valor encontrado (ainda sem indice) e atribuimos um √≠ndice com max_node->index = size.

  - 1.¬™ itera√ß√£o: o maior valor absoluto recebe index = N-1.
  - 2.¬™ itera√ß√£o: o 2.¬∫ maior recebe index = N-2.
                        ‚Ä¶
  - √∫ltima itera√ß√£o: o menor recebe index = 0.

  - Isto cria uma compress√£o ordenada (ranking) 0..N-1, onde 0 √© o menor e N-1 o maior.

  
Inicializa√ß√£o: current = stack_a;
		       max_node = NULL;
		       max_val = INT_MIN;

> Recome√ßamos no √≠nicio da lista (current = stack_a). Como current √© o ponteiro para percorrer a linked list do inicio ao fim
  (percorre cada node um a um) a cada itera√ß√£o externa - while(size-- > 0) - vamos voltar a percorrer toda a lista √† procura do 
  pr√≥ximo maior valor.
  Por isso, fazemos sempre current = stack_a para recome√ßar novamente no head da lista.
  COmo vamos ver, depois disso fazemos while(current) e vamos avan√ßando com current = current->next at√© chegar ao fim (NULL).
  QUando acabamos de percorrer a lista √† procura do pr√≥ximo maior valor, voltamos ao √≠ncio para procurarmos o pr√≥ximo.

  Exemplo: Lista 40 ‚Üí -5 ‚Üí 12 ‚Üí 7

           1¬™ itera√ß√£o: current come√ßa em 40 ‚Üí percorre tudo.
           2¬™ itera√ß√£o: voltamos a p√¥r current = stack_a ‚Üí come√ßa de novo em 40 ‚Üí percorre tudo outra vez.

           Isto repete-se N vezes.

> Ainda n√£o temos/encontramos o maior node (max_node == NULL).
  Como max_node guarda o endere√ßo do node que cont√©m o maior valor encontrado at√© agora (nesta itera√ß√£o do loop), inicialmente,
  ele √© NULL porque ainda n√£o analisamos nenhum node.
  Durante o loop, cada vez que encontrarmos um valor maior do que o atual max_val, fazemos max_node = current.
  Assim, max_node guarda o endere√ßo do node que tem esse maior valor (max_val).

  Exemplo: Na lista 40 ‚Üí -5 ‚Üí 12 ‚Üí 7
  
           1¬™ itera√ß√£o: come√ßa max_node = NULL
                        v√™ 40 ‚Üí max_node = (node do 40)
                        v√™ -5 ‚Üí n√£o muda
                        v√™ 12 ‚Üí n√£o muda
                        v√™ 7 ‚Üí n√£o muda

           fim: max_node aponta para o n√≥ do 40.
  
> O maior valor visto (max_val) come√ßa no menor poss√≠vel (INT_MIN) para garantir que qualquer valor da lista (value) ser√° maior
  ou igual (>=) a este logo na primeira compara√ß√£o. Exemplo: se o 1¬∫ node for -50, ele ainda assim √© maior que INT_MIN ‚Üí logo substitui.
  Se come√ßassemos em 0, perderiamos n√∫meros negativos (ex: numa lista s√≥ de negativos, nenhum seria maior que 0 e max_node ficava errado).
  Usar >= em vez de > aqui n√£o muda nada no projeto, porque j√° garantimos que n√£o h√° duplicados.
  (Se houvesse dois valores iguais, acabariamos por escolher o √∫ltimo que aparece na lista ‚Äî o que tamb√©m seria aceit√°vel.)
  Assim, max_val compara e guarda o maior valor encontrado at√© agora.
  Como vamos ver, durante o loop, cada vez que vemos um current->value maior do que max_val, atualizamos:

  max_val  = current->value;
  max_node = current;

> No fim do loop: - max_node aponta para o node com o maior valor ainda sem √≠ndice.
                  - max_node->index = size; atribui-lhe o √≠ndice correto.

                  Depois a pr√≥xima itera√ß√£o repete tudo, mas agora esse node j√° n√£o entra (porque index != 0).

Loop while (current)

> Vamos percorrer a linked list stack_a do √≠nicio ao fim.
> O loop termina quando chegamos ao fim da lista (NULL).
> Verificamos se : - current->index == 0 ‚Üí s√≥ consideramos nodes que ainda n√£o receberam um indice. 
                     No in√≠cio, todos os indices s√£o 0 (definido na fun√ß√£o ft_lst_new.
                     Cada vez que atribuimos um indice a um node (max_node->index = size), esse node deixa de ser 0 e ser√°
                     ignorado nas itera√ß√µes seguintes.
                   - current->value >= max_val ‚Üí comparamos o valor atual (value) da lista com o maior valor encontrado at√© 
                     agora (max_val).
                     Se for maior ou igual, significa que encontramos um novo candidato a maior n√∫mero desta itera√ß√£o, pelo 
                     o que atualizamos.
                     O >= aqui n√£o muda nada em inputs v√°lidos (n√£o temos duplicados), mas n√£o faz mal: se houvesse duplicados,
                     ficaria com o √∫ltimo.
                     
> Atualiza√ß√£o do maior valor visto (max_val)

  Se a condi√ß√£o for satisfeita, atualizamos max_val (max_val = current->value), pelo que agora este √© o novo maior valor encontrado.
  
  Exemplo: Antes: max_val = -2147483648 (INT_MIN)
           Current: 40
           Depois: max_val = 40.

  De seguida, guardamos o endere√ßo do node que tem esse valor (max_node = current), assim sabemos quem √© o maior node desta itera√ß√£o.
  Isto serve para quando o loop acabar, fazermos max_node->index = size para atribuirmos o indice correto.

> Avan√ßar para o pr√≥ximo node da lista (current = current->next)
                     
> Atribui√ß√£o do √≠ndice:

  if (max_node)
            max_node->index = size;

  Durante o loop interno encontramos o maior valor visto at√© agora entre os nodes com index == 0 (max_val) e guardamos o endere√ßo desse 
  node (ainda sem indice) em max_node.
  Come√ßamos por verificar se a lista tem pelo menos um node ainda sem √≠ndice, no final do loop, max_node n√£o √© NULL - if (max_node).
  
   Se encontramos o maior node (max_node), atribuimos a ele um indice (index = size).
   Dentro deste while (size-- > 0), o size j√° foi decrementado:
   
      - 1¬™ vez: size √© N-1 ‚Üí o maior recebe N-1.
      - 2¬™ vez: size √© N-2 ‚Üí o 2¬∫ maior recebe N-2.
                        ‚Ä¶
      - √∫ltima vez: size √© 0 ‚Üí o menor recebe 0.

    Exemplo: stack_a com valores: [ 40, -5, 12, 7 ], N=4.

    Itera√ß√£o 1 (size = 3): percorre -> maior sem √≠ndice = 40 -> index(40) = 3

    Itera√ß√£o 2 (size = 2): sem √≠ndice: -5, 12, 7 ‚Üí maior = 12 -> index(12) = 2

    Itera√ß√£o 3 (size = 1): sem √≠ndice: -5, 7 ‚Üí maior = 7 -> index(7) = 1

    Itera√ß√£o 4 (size = 0): sem √≠ndice: -5 -> index(-5) = 0

    Resultado final (value ‚Üí index): [40(3)] ‚Üí [-5(0)] ‚Üí [12(2)] ‚Üí [7(1)]


   Porqu√™ que esta fun√ß√£o √© importante no push_swap ?

   > Depois de ft_index_stack, o algoritmo passa a trabalhar com o indice em vez do value.
   > Em ft_push_to_b, empurramos para B os elementos com indice menor/num intervalo, o que define os ‚Äúchunks‚Äù.
   > O c√°lculo do target (onde inserir em A) compara √≠ndices, n√£o valores ‚Üí mais direto, sem lidar com negativos, limites, etc.
   > O c√°lculo de cost_a/cost_b tamb√©m √© guiado por pos/index, e as rota√ß√µes combinadas s√£o decididas a partir disso.


1.5) ft_push_swap(&stack_a, &stack_b, ft_size(stack_a)); 

static void	ft_push_swap(t_stack **stack_a, t_stack **stack_b, int size)
{
	if (size == 2 && !ft_is_sorted(*stack_a))  [a]
		ft_sa(stack_a);  [b]
	else if (size == 3 && !ft_is_sorted(*stack_a))
		ft_sort_three(stack_a); [c]
	else if (size > 3 && !ft_is_sorted(*stack_a))
		ft_sort(stack_a, stack_b);  [d]
}

Na fun√ß√£o ft_push_swap(), escolhemos a estrat√©gia de ordena√ß√£o conforme o tamanho e s√≥ √© executado se ainda n√£o estiver ordenado.

Vejamos primeiro como funciona a fun√ß√£o ft_is_sorted():

[a] 

int	ft_is_sorted(t_stack *stack)
{
	while (stack && stack->next)
	{
		if (stack->value > stack->next->value)
			return (0);
		stack = stack->next;
	}
	return (1);
}

Esta fun√ß√£o verifica se a stack A j√° se encontra ordenada (em ordem crescente) do topo para a base, ou seja, estar ordenada 
significa que cada node tem um value inferior ou igual (<=) ao value do node seguinte. A verifica√ß√£o aqui √© por valor e n√£o
por indice.
Como no push swap n√£o h√° n√∫meros duplicados, na pr√°tica a ordem √© estritamente crescente.

A fun√ß√£o recebe o head da linked list t_stack.

> while (stack && stack->next)
  
  Vamos percorrer a lista par a par (node atual vs. pr√≥ximo node).
  A condi√ß√£o garante que h√° um pr√≥ximo node para comparar. Evita NULL->value.
  Se a lista estiver vazia (stack == NULL) ou tiver um s√≥ node (stack->next == NULL), o while n√£o entra ‚Üí n√£o existem quebras 
  ‚Üí retorna 1 no fim (correto: listas de 0/1 elemento est√£o ‚Äúordenadas‚Äù).

  > if (stack->value > stack->next->value) 
        return (0)

    Verifica se h√° uma invers√£o: ‚Äúo valor do node atual √© maior do que o valor do pr√≥ximo node ?‚Äù
    Se sim, encontrou uma ordem decrescente naquele par ‚Üí n√£o est√° ordenado ‚Üí devolve 0 imediatamente.
    Caso contr√°rio, continua e ignora este if.
    
  > stack = stack->next: Avan√ßa para o node seguinte e repete a compara√ß√£o com o node seguinte a ele.

  > return (1): Se percorreu todos os nodes sem encontrar value > next->value, ent√£o est√° ordenada ‚Üí devolve 1.



No √≠nicio da fun√ß√£o ft_push_swap() vamos come√ßar por verificar se a stack A tem exatamete dois nodes (size == 2) e 
se ela n√£o se encontra ordenada em ordem crescente (!ft_is_sorted(*stack_a)).

> if (size == 2 && !ft_is_sorted(*stack_a))
    ft_sa(stack_a);

  Se s√≥ temos 2 n√∫meros e n√£o est√£o ordenados, apenas um √∫nico swap (sa) resolve (trocar os dois do topo).

  [b]

   void	ft_sa(t_stack **stack_a)
   {
	   ft_swap(*stack_a);
	   ft_putstr_fd("sa\n", 1);
   }

   static void	ft_swap(t_stack *stack)
   {
	  int	temp;

	  if (!stack || !stack->next)  // se tivessemos menos de 2 nodes n√£o havia nada para trocar
		  return ;
      // trocar os "values"
	  temp = stack->value;
	  stack->value = stack->next->value;
	  stack->next->value = temp;
      // trocar os "indices"
	  temp = stack->index;
	  stack->index = stack->next->index;
	  stack->next->index = temp;
   }

   Porque que trocamos tamb√©m os indices ?

   Porque index √© o r√≥tulo do valor (rank). Se trocassemos s√≥ os value, ficavamos com pares incoerentes (o node com
   value = 1 mas index que pertencia ao 2). Trocando os dois campos, √© como se tivessemoss ‚Äútrocado os nodes‚Äù sem
   mexermos em next ‚Äî o par (value, index) continua coerente.


> else if (size == 3 && !ft_is_sorted(*stack_a))
    ft_sort_three(stack_a);

  Se temos 3 n√∫meros e a stack n√£o est√° ordenada -> usamos o algortimo fixo para tr√™s elementos (ft_sort_three).

  void	ft_sort_three(t_stack **stack_a)
  {
	  int	high;

	  if (ft_is_sorted(*stack_a))        // se j√° estiver ordenada
		  return ;                        // sai
          
	  high = ft_find_high(*stack_a); [c2]   // encontra o maior value na stack A
      
	  if ((*stack_a)->value == high)   // verifica se o maior value est√° no topo
		  ft_ra(stack_a); [c3]         // se sim, manda-o do topo para a base -> o maior vai para a base
	  else if ((*stack_a)->next->value == high)  // verifica se o maior est√° no meio
		  ft_rra(stack_a); [c4]             // se sim, desloca o que est√° na base para o topo -> o maior desliza para a base
	  if ((*stack_a)->value > (*stack_a)->next->value)  // verifica se os dois de cima (topo e o meio) est√£o desordenados
		  ft_sa(stack_a);  [c5]           // se estiverem, troca-os para obtermos topo < meio
  }

  A fun√ß√£o ft_sort_three() ordena a stack A (do topo para a base), em ordem crescente, com o minimo de opera√ß√µes.

  Imaginemos a stack A:

  Topo (head)  ‚Üí  [a]  ‚Üí  [b]  ‚Üí  [c]  ‚Üí  NULL  =  Base (fundo)
                   ^topo   ^meio   ^base

   As opera√ß√µes usadas: - sa ‚Üí troca os dois do topo ([a] com [b]).
                        - ra ‚Üí roda para cima: o topo vai para a base  ->  [a, b, c] ‚Üí ra ‚Üí [b, c, a]
                        - rra ‚Üí roda para baixo: a base vem para o topo.  ->  [a, b, c] ‚Üí rra ‚Üí [c, a, b]

   A ideia √© p√¥r o maior na base com 1 rota√ß√£o (ra ou rra) e depois, se os dois de cima estiverem desordenados, fazer 1 swap (sa).
   Com isso ficamos com a stack A ordenada, do topo para a base [menor, m√©dio, maior].
                                                                   ^topo  ^meio  ^base

   Como isto funciona sempre ? Com 3 elementos, h√° s√≥ 6 ordens poss√≠veis em que em todas elas:

        > com um rotate ou reverse rotate (ra ou rra) conseguimos colocar o maior na base.
        
              [a, b, c] ‚Üí ra ‚Üí [b, c, a]   ou   [a, b, c] ‚Üí rra ‚Üí [c, a, b]

        > se os dois de cima (o topo e o meio) estiverem desordenados (topo > meio), trocamos eles com o swap (sa).
        
    Utilizamos assim no m√°ximo duas opera√ß√µes.

    A fun√ß√£o ft_sort_three() precisa de saber onde est√° o maior dos tr√™s para decidir que rota√ß√£o fazer:

        - se o maior est√° no topo ‚Üí ra (o topo vai para a base)  ->  [a, b, c] ‚Üí ra ‚Üí [b, c, a]
        - se o maior est√° no meio ‚Üí rra (a base vai para o topo, empurrando o meio para a base)  ->  [a, b, c] ‚Üí rra ‚Üí [c, a, b]
        - se n√£o est√° no topo nem no meio, ent√£o est√° na base ‚Üí n√£o roda.

        
    Vejamos como vamos descobrir o maior value que existe na stack A, com a fun√ß√£o ft_find_high() :
                                 
    [c2] high = ft_find_high(*stack_a);

    int	ft_find_high(t_stack *stack)
    {
	    int	high;

	    high = INT_MIN;
	    while (stack)
	    {
		    if (stack->value > high)
		  	    high = stack->value;
		    stack = stack->next;
	    }
	    return (high);
    }

    A fun√ß√£o ft_sort_three precisa de saber onde est√° o node com maior value dos tr√™s nodes para decidir que rota√ß√£o fazer.

    > t_stack *stack √© o ponteiro para o head da linked list. Cada node (t_stack) tem pelo menos:
      
        - int value -> o n√∫mero que queremos ordenar.
        - t_stack *next -> o ponteiro para o pr√≥ximo node (ou NULL, no √∫ltimo node). 

    > int high √© a vari√°vel onde vamos guardar o maior valor encontrado at√© ao momento.
      Iniciamos o high em INT_MIN (o menor inteiro poss√≠vel) para come√ßar pelo valor mais baixo de modo a garantir que o primeiro
      node que virmos seja value > high, atualizando o high e sendo at√© esse momento o maior valor encontrado.
      Funciona para todos os casos, inclusive quando os n√∫meros s√£o negativos.

    A linked list √© uma cadeia de nodes:

    head ‚Üí [value = 40, next = &n2] -> [value = -5, next = &n3] -> [value = 12, next = &n4] -> [value = 7, next = NULL] ‚Üê tail

    O while (stack) vai:

    - Ler o node atual (aquele para onde o stack aponta agora, no √≠nicio aponta para o head).
    - Compara o seu value com o high.
    - Se for maior, atualiza high.
    - Avan√ßa com stack = stack->next, movendo para o node seguinte.
    - Repete at√© stack == NULL (fim da lista).

    NOTA: Aqui n√£o alteramos a lista, apenas s√≥ lemos o value e seguimos o ponteiro next.

    
    Agora vamos verificar se o maior value est√° no topo:
    
    if ((*stack_a)->value == high)
        ft_ra(stack_a); 

    A ideia aqui √© colocar o maior value na base da stack A com uma rota√ß√£o. Se ele estiver no topo (se for o head),
    fazemos rotate (ra):

    [c3]

    void	ft_ra(t_stack **stack_a)
    {
	    ft_rotate(stack_a);
	    ft_putstr_fd("ra\n", 1);
    }

    static void	ft_rotate(t_stack **stack)
    {
	    t_stack	*temp;
	    t_stack	*last;

	    if (!*stack || !(*stack)->next)   // se tiver 0 ou 1 node n√£o h√° nada a fazer
		    return ;
	    temp = *stack;                  // guarda o head antigo (node1)
	    *stack = (*stack)->next;        // avan√ßa o head para o node2 (novo topo)
	    last = ft_last(*stack);         // encontra o tail a partir do novo head
	    temp->next = NULL;              // o antigo head (topo) vai ser o novo tail -> next = NULL
	    last->next = temp;              // liga o antigo head (topo) ao fim da lista
    }

    O rotate A (ra) move o topo (head) da stack A para a base.
    A fun√ß√£o ft_ra() recebe um t_stack ** porque a rota√ß√£o altera o head (topo) da lista.
    Se a fun√ß√£o recebesse t_stack *stack (c√≥pia do ponteiro), s√≥ mudariamos a c√≥pia local e o chamador 
    continuaria a apontar para o head antigo.
    
    > Estado inicial: 
    
    *stack  ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
                 ^topo              ^base
                 
    O ponteiro *stack aponta para o head (topo) da lista, que neste caso vai ser o N1.

    > temp = *stack // guardamos o head antigo (N1)

    Aqui, copiamos o ponteiro do head para uma vari√°vel tempor√°ria (temp).
    Agora ficamos com dois ponteiros que fazem referencia ao mesmo node N1: *stack e temp.

      temp ‚îÄ‚îÄ‚îê
             ‚ñº
     *stack ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
                  ^topo

    Nada na lista mudou; apenas guard√°mos o acesso ao antigo topo para o reaproveitar no fim.

    > *stack = (*stack)->next; // avan√ßa o head para N2 (novo topo)

    Mudamos o head (visto pelo chamador) para o segundo node.
    Depois desta linha, o novo topo √© o node N2. 
    O temp continua a apontar para N1.

    temp   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
    
    *stack ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
                ^topo
    
    A lista ainda est√° ligada do mesmo jeito; s√≥ o ponteiro do head √© que mudou.

    
    > last = ft_last(*stack); // encontra o tail a partir do novo head

    Chamamos a fun√ß√£o ft_last() a partir do novo head (N2) para descobrir o √∫ltimo node (tail), que √© N3.
    A fun√ß√£o vai percorrer at√© encontrar o node cujo next == NULL.
                
    last  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL

    temp  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL

    *stack ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
                ^topo     ^tail (last)

                
    > temp->next = NULL; // o antigo head (N1) vai ser o novo tail ‚Üí next = NULL

    Estamos a preparar N1 (o antigo topo) para o colocar no fim.
    Definimos que depois dele n√£o h√° mais nenhum node.

    temp (N1) ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ NULL          [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
    
    *stack   ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL

    last     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3]

    Ainda n√£o lig√°mos N1 ao resto ‚Äî s√≥ o deix√°mos ‚Äúisolado‚Äù com next = NULL.

    
    > last->next = temp; // liga o antigo head (N1) ao fim da lista

    *stack ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ NULL
                 ^topo                              ^novo tail

    Agora fazemos a liga√ß√£o final: o antigo tail (N3) passa a apontar para N1.
    Assim, N1 torna-se o novo tail.

    Fizemos assim a rota√ß√£o para cima - o topo antigo foi enviado para a base e o 
    segundo node tornou-se o novo topo.

    
    Vamos verificar o caso de o maior estar no meio da lista:

    else if ((*stack_a)->next->value == high)  // verifica se o maior est√° no meio
		 ft_rra(stack_a); [c4]             // se sim, desloca o que est√° na base para o topo -> o maior desliza para a base

    Se o maior estiver no meio, uma rota√ß√£o para baixo (rra) traz o √∫ltimo node (base) para o topo.
    QUando isso acontece com 3 elementos, o node do meio desce uma posi√ß√£o e vai parar √† base - que √© onde queremos o maior.

    A fun√ß√£o ft_rra() move a base (o √∫ltimo node) para o topo.

    [c4]

    void	ft_rra(t_stack **stack_a)
    {
	    ft_reverse_rotate(stack_a);
	    ft_putstr_fd("rra\n", 1);
    }

    static void	ft_reverse_rotate(t_stack **stack)
    {
	    t_stack	*temp;
	    t_stack	*last;
	    t_stack	*before_last;

	    if (!*stack || !(*stack)->next)
		    return ;
            
	    last = ft_last(*stack);
	    before_last = ft_before_last(*stack);
	    temp = *stack;                          // guarda o head antigo
        
	    *stack = last;             // o novo head passa a ser o tail
	    (*stack)->next = temp;     // o antigo head fica a seguir ao novo head
	    before_last->next = NULL;  // corta a lista no antes do ultimo node - ele torna-se o nove tail
    }

    > Estado Inicial: 

    *stack ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
                ^topo              ^base (tail)

    O node N2 √© o node que cont√©m o maior valor (value).

    
    > last = ft_last(*stack);

    Procura o √∫ltimo node (tail), partindo do head:

    last ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
    
    *stack ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL

    
    > before_last = ft_before_last(*stack);

    t_stack	*ft_before_last(t_stack *stack)
    {
	    while (stack && stack->next && stack->next->next)
		    stack = stack->next;
	    return (stack);
    }

    Procura o node antes do √∫ltimo (antes do tail):

    before_last ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
    
    last         ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3]

    *stack       ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
    
    
    > temp = *stack; // guarda o head antigo (topo)

    temp   ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL
    
    *stack ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL

    before_last ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N2]

    last        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3]

    
    > *stack = last; // o novo head passa a ser o tail

    Agora o novo topo √© o antigo tail (N3):

    stack ‚îÄ‚îÄ‚ñ∫ [N3]      (novo topo)
    
    temp   ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ NULL

    before_last ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N2]

    last        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3]


    > (*stack)->next = temp; // liga o novo topo ao antigo head

    Faz N3->next = N1, ligando o antigo head a seguir ao novo head:

    *stack ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ ...  ‚ùå (h√° um ciclo!)
                 ^topo

    temp   ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚Ä¶

    before_last ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N2]

    last        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ [N3]

    Neste momento, se n√£o cortarmos o tail antigo, criamos um ciclo (porque N2->next ainda aponta para N3,
    e N3->next aponta agora para N1). O pr√≥ximo passo resolve isso.


    > before_last->next = NULL; // corta no ‚Äúantes do √∫ltimo‚Äù

    Define que o novo tail √© o before_last (N2), cortando a liga√ß√£o antiga N2->next = NULL:

    *stack ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ NULL
                ^topo              ^novo tail


    Depois de garantirmos que o node com o maior value est√° na base (com ra, caso estivesse no topo ou com rra no caso 
    estivesse no meio), s√≥ falta agora ordenar os dois de cima (o topo e o meio) de modo a que fiquem em ordem crescente:

    if ((*stack_a)->value > (*stack_a)->next->value)  // topo > meio ?
        ft_sa(stack_a);

    Por que s√≥ precisamos ver estes dois nodes?

    Na fun√ß√£o ft_sort_three(), j√° tratamos de p√¥r o maior na base (com ra ou rra).
    Logo, a base est√° correta (o maior deve ficar na base).

    S√≥ resta ‚Äúarrumar‚Äù os dois de cima.
    Se topo > meio, trocamos; se topo < meio, n√£o fazemos nada.

    Isto garante o sort com no m√°ximo 2 instru√ß√µes (ra/rra + sa opcional).

    > *stack_a ‚Üí √© o topo (head) da lista.

    > (*stack_a)->next ‚Üí √© o meio (o segundo node).

    > (*stack_a)->value > (*stack_a)->next->value   ‚Üí   ‚ÄúO valor do topo √© maior do que o valor do meio?‚Äù

       - Se sim, ent√£o os dois n√£o est√£o ordenados (devia ser topo < meio numa lista crescente).
       - Se n√£o, j√° est√£o na ordem certa.

    No push_swap n√£o h√° duplicados, logo a ordem ‚Äúcerta‚Äù √© estritamente crescente: topo < meio.

    A fun√ßa√µ ft_sa() troca os dois primeiros nodes da stack A (troca os conte√∫dos value e o index do topo e do meio).
    Isto corrige imediatamente a ordem desses dois:

    Antes (errado): [ topo=5, meio=2, base=MAIOR ] ‚Üí  sa  ‚Üí Depois (certo): [ topo=2, meio=5, base=MAIOR ]

    Como o node com o value maior j√° foi colocado na base no passo anterior, depois deste sa (se necess√°rio) a pilha fica: [menor, m√©dio, maior]
    

    Voltando √Ä fun√ß√£o ft_push_swap(), vamos debater-nos sobre o caso de haver mais do que 3 nodes na lista e estes n√£o estarem ordenados:

    > else if (size > 3 && !ft_is_sorted(*stack_a))
		ft_sort(stack_a, stack_b);
        
    Se temos mais do que 3 n√∫meros e est√£o desordenados -> entra no algoritmo completo ("turkish + reinser√ß√£o pelo movimento com menos custo").


    > ft_sort(stack_a, stack_b)
    
    void	ft_sort(t_stack **stack_a, t_stack **stack_b)
    {
	    ft_push_to_b(stack_a, stack_b);  // aqui dividimos: tiramos quase todos da stack A para a stack B
	    ft_sort_three(stack_a);  // ordenamos rapidamente os 3 que ficaram na stack A
	    while (*stack_b)         // enquanto houver na stack B, reinserimos da stack B para a stack A, sempre no s√≠tio certo e pelo menor custo
	    {
		    ft_assign_pos(stack_a, stack_b);  // calculamos a posi√ß√£o de A e B e o target de cada node de B
		    ft_cost(stack_a, stack_b);    // calculamos os custos (ra/rra, rb/rrb) com sinal
		    ft_cheapest(stack_a, stack_b);  // escolhemos e executamos o movimento total mais barato e fazemos pa
	    }
	    if (!ft_is_sorted(*stack_a) && *stack_a)  // ajuste final
		    ft_stack_shift(stack_a);  // roda A at√© o menor indice (0) ficar no topo
    }

    √â nesta fun√ß√£o, do push swap, que transformamos uma stack A com mais do que 3 n√∫meros numa stack A ordenada (topo -> base).

    O objetivo da fun√ß√£o ft_sort() √© levar a stack_a do estado desordenada e demasiado grande para o estado de ordenada e com o 
    node menor no topo, deixando a stack B vazia.
    Temos, assim, de deixar a stack A ordenada (topo -> base) e a stack B vazia, imprimindo a menor quantidade razo√°vel de instru√ß√µes.

    No fim do processo, a stack B fica vazia. A stack A fica toda ordenada e com o menor no topo.

    

    > ft_push_to_b(a, b)

    static void	ft_push_to_b(t_stack **stack_a, t_stack **stack_b)
    {
	    int	size;
	    int	i;
	    int	is_pushed;

	    size = ft_size(*stack_a);                    // tamanho inicial da stack A
	    is_pushed = 0;                               // quantos pb j√° fizemos (quantos sairam da stack A)
	    i = 0;                                       // quantas visitas (itera√ß√µes) ao topo j√° fizemos
        
	    while (size > 6 && i < size && is_pushed < size / 2) 
	    {
		    if ((*stack_a)->index <= size / 2)        // verificamos se o topo tem um indice baixo
		    {
			    ft_pb(stack_a, stack_b);  [d2]        // se tiver, empurramos para a stack B
			    is_pushed++;
		    }
		    else
			    ft_ra(stack_a);  [d2]                 // se n√£o tiver, rodamos A (ra) para experimentarmos outro topo, √† procura de algu√©m com indice mais baixo
		    i++;
	    }
	    while (size - is_pushed > 3)                  // enquanto a stack A tiver mais que 3
	    {
	    	ft_pb(stack_a, stack_b);  [d2]            // empurramos para a stack B
	    	is_pushed++;
	    }
    }

    Utilizamos esta fun√ß√£o pois ordenar uma lista grande s√≥ com rota√ß√µes/trocas sai caro.

    O objetivo √© deixarmos apenas 3 elementos na stack A (f√°ceis de ordenar). Como fazemos isso? Empurramos da stack A para a stack B 
    quase todos os elementos, privilegiando que os de √≠ndice mais baixo saiam primeiro.
    No fim, a stack A fica com 3 nodes e a stack B fica com o resto.

    O que isto garante? Reduz drasticamente a complexidade: a stack A vira uma esp√©cie de ‚Äún√∫cleo‚Äù pequeno e a stack B guarda o volume.

    Assim: - Movemos de A para B aproximadamente metade dos elementos com √≠ndices baixos (0..N/2) e, depois, empurramos mais at√© 
             sobrarem 3 nodes em A.
           - Usa o index (0..N-1) para decidir quem empurrar: comparar √≠ndices √© simples e independente do sinal/magnitude dos 
             valores reais.

    Sem esta fase: ficariamos a tentar ordenar tudo dentro de A, com muito mais ra/rra/sa ‚Äî gastariamos muitas opera√ß√µes.
    
    
    > o que √© ‚Äú√≠ndice baixo‚Äù ? Depois da fun√ß√£o ft_index_stack(), cada node ficou com um index ‚àà [0..N-1]:

      - 0 = menor valor e N-1 = maior valor.
      
      - O ‚Äú√≠ndice baixo‚Äù = indice perto de 0.
    
      A fun√ß√£o usa isto para empurrar primeiro os ‚Äúpequenos‚Äù para B.

    > size: √© o n√∫mero de nodes que a stack_a cont√©m. Serve para termos um limiar fixo (size / 2) para decidir os indices baixos e 
            para controlar quantas itera√ß√µes vamos fazemos no primeiro loop (na condi√ß√£o i < size).

    > is_pushed: √© o n√∫mero de quantos nodes empurramos de A para B (quantos pb fizemos), ou seja, quantos nodes sa√≠ram da stack A.
                 Em qualquer momento, size - is_pushed, significa "quantos nodes ainda est√£o na stack A".

    
    Vejamos como isto funciona:

    Fase 1 - Fase dos chunks (se size > 6): 

    > while (size > 6 && i < size && is_pushed < size / 2)
      
    Se o topo tem √≠ndice baixo (<= size / 2) -> empurramos da stack A para a stack B (pb).
    Caso contr√°rio, rodamos a stack A, trazendo outro node ao topo para testarmos.
    EM qualquer caso, i++, contamos com uma visita ao topo.

    O loop para quando visitamos todos os size topos ou quando j√° empurramos size / 2 nodes da stack A para a stack B.

    Numa √∫nica ronda sobre os size topos, tentamos tirar aproximadamente metade (aqueles com index <= size /2 - os 
    de indice mais baixo) da stack A e empurramos para a stack B, deixando a stack B carregada de indices baixos e a 
    stack A com uma boa parte dos indices altos.

    Fase 2 - Garantir 3 nodes restantes na stack A
    
    > while (size - is_pushed > 3)  // enquanto a stack A tiver mais do que 3 nodes, fazemos pb
    
    Independentemente do que aconteceu acima, empurramos para B at√© ficarmos s√≥ com 3 na stack A.
    
        - Para size = 4, vamos empurrar 1; size = 5 empurramos 2; size = 6 empurramos 3; etc.

    Caso size <= 6, saltamos a primeira fase (o primeiro while) e vamos diretos para este loop. 
    SImplesmente, empurramos at√© sobrarem 3 elementos na stack A (sem sele√ß√£o por indice).

        O crit√©rio do ‚Äú3 restantes‚Äù √© porque temos a fun√ß√£o ft_sort_three() para lidar com os 3 elementos.


    > O que pb faz: 
    
      - pb ‚Äî ‚Äúpush B‚Äù: move o topo (head) de A para o topo (head) de B

        Antes: A (topo‚Üí) [A1] ‚Üí [A2] ‚Üí [A3] ‚Üí ...
               B (topo‚Üí) [B1] ‚Üí [B2] ‚Üí ...

        Com pb: - Na stack A a head passa a ser A2.
                - Na stack B, a nova head passa a ser A1.

        Depois: A: [A2] ‚Üí [A3] ‚Üí ...
                B: [A1] ‚Üí [B1] ‚Üí [B2] ‚Üí ...
        
                
        void	ft_pb(t_stack **stack_a, t_stack **stack_b)
        {
	        ft_push(stack_a, stack_b);
	        ft_putstr_fd("pb\n", 1);
        }

        void	ft_push(t_stack **src, t_stack **dest)
        {
	        t_stack	*temp_src;
	        t_stack	*temp_dest;

	        if (!*src)
		        return ;
	        temp_src = *src;
	        temp_dest = *dest;
	        *src = temp_src->next;
	        *dest = temp_src;
	        temp_src->next = temp_dest;
        }

        > Estado inicial:

        src √© a nossa stack A e dest √© a nossa stack B.
        Assim:

        stack_a (*src)  ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ [ A3 ] ‚îÄ‚îÄ‚ñ∫ NULL
                               ^ topo A 
        
        stack_b (*dest) ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...      ‚îÄ‚îÄ‚ñ∫ NULL
                               ^ topo B

                               
        > temp_src = *src;  (temp_stack_a = *stack_a)

        Guarda o endere√ßo do head/topo da src (stack_a) (o node que vamos deslocar).
        
        temp_stack_a ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ ...
        
        *stack_a     ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ ...

        *stack_b    ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...

        
        > temp_dest = *dest;  (temp_stack_b = *stack_b)

        Guarda o endere√ßo do head/topo da dest (stack_b) (para encaixar depois o movido ‚Äúem cima‚Äù dele).

        temp_stack_b ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...
        
        temp_stack_a  ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ ...
        
        *stack_a      ‚îÄ‚ñ∫ [ A1 ] ...
        
        *stack_b     ‚îÄ‚ñ∫ [ B1 ] ...
        

        > *src = temp_src->next;  (*stack_a = temp_stack_a->next)

        Avan√ßamos o head da stack_a (src): agora o novo head/topo da stack_a √© A2.

        *stack_a      ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ [ A3 ] ‚îÄ‚îÄ‚ñ∫ ...
    
        temp_stack_a  ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ ...

        *stack_b     ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...

        temp_stack_b ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...

        
        > *dest = temp_src;  (*stack_b = temp_stack_a)

        O head da stack_b passa a ser o node movido A1.

        *stack_b      ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ ...   (ainda n√£o correcto; falta apontar o next de A1 para o head antigo de B)

        temp_stack_a  ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ ...

        temp_stack_b  ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...

        *stack_a      ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ [ A3 ] ‚îÄ‚îÄ‚ñ∫ ...


        > temp_src->next = temp_dest;  (temp_stack_a->next = temp_stack_b)

        Liga o node movido (A1) por cima do que era o head da stack B (dest), B1.

        *stack_b     ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...

        *stack_a      ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ [ A3 ] ‚îÄ‚îÄ‚ñ∫ ...


        Recapitulando: 
        
        Antes: src (*src)  ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ [ A3 ] ‚îÄ‚îÄ‚ñ∫ NULL
                                  ^ topo A

               dest(*dest) ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...      ‚îÄ‚îÄ‚ñ∫ NULL
                                  ^ topo B

        Depois: src (*src)  ‚îÄ‚îÄ‚ñ∫ [ A2 ] ‚îÄ‚îÄ‚ñ∫ [ A3 ] ‚îÄ‚îÄ‚ñ∫ NULL
                                   ^ novo topo A

                dest(*dest) ‚îÄ‚îÄ‚ñ∫ [ A1 ] ‚îÄ‚îÄ‚ñ∫ [ B1 ] ‚îÄ‚îÄ‚ñ∫ [ B2 ] ‚îÄ‚îÄ‚ñ∫ ...
                                   ^ novo topo B

    Por que usamos o √≠ndice (e n√£o o value)?

    Decidir pelo index (0..N-1) √© super simples para ‚Äúdividir pela metade‚Äù (index <= size/2) e n√£o depende de sinais/magnitudes.
    Pequeno exemplo (N=8, √≠ndices no topo‚Üíbase)

    Suponhamos A come√ßa: A: [7, 0, 5, 3, 6, 1, 4, 2] 
                         B: [], 
                         size = 8

    Fase 1 (size > 6 e queremos empurrar ~4 (size / 2 = 8 / 2) vezes):

        - Para i = 0, o topo = 7 (como 7 > 4, √© alto) ‚Üí ra
        - Para i = 1, o topo = 0 (como 0 < 4, √© baixo) ‚Üí pb (B:[0])
        - Para i = 2, o topo = 5 (como 5 > 4, √© alto) ‚Üí ra
        - Para i = 3, o topo = 3 (como 3 < 4, √© baixo) ‚Üí pb (B:[3,0])
        - Para i = 4, o topo = 6 (como 6 > 4, √© alto) ‚Üí ra
        - Para i = 5, o topo = 1 (como 1 < 4, √© baixo) ‚Üí pb (B:[1,3,0])
        - Para i = 6, o topo = 4 (como 4 == 4, √© baixo) ‚Üí pb (B:[4,1,3,0]) ‚Üí j√° empurr√°mos 4 = size / 2 ‚Üí Fase 1 termina

    A: [2,7,5,6]
    B: [4,1,3,0]     (maioria √≠ndices baixos em B)

    Fase 2: ficar s√≥ com 3 na stack A ‚Üí size - is_pushed = 8 - 4 = 4 ‚Üí empurramos mais um para ficar com 3.

    A: [7,5,6]
    B: [2,4,1,3,0]

    
    > ft_sort_three(a)

    Com 3 elementos na stack A, conseguimos ordenar em <= 2 instru√ß√µes.

    A fun√ß√£o ft_sort_three() ordena a stack A (do topo para a base), em ordem crescente, com o minimo de opera√ß√µes.

    Imaginemos a stack A:

    Topo (head)  ‚Üí  [a]  ‚Üí  [b]  ‚Üí  [c]  ‚Üí  NULL  =  Base (fundo)
                     ^topo   ^meio   ^base

    As opera√ß√µes usadas: - sa ‚Üí troca os dois do topo ([a] com [b]).
                         - ra ‚Üí roda para cima: o topo vai para a base  ->  [a, b, c] ‚Üí ra ‚Üí [b, c, a]
                         - rra ‚Üí roda para baixo: a base vem para o topo.  ->  [a, b, c] ‚Üí rra ‚Üí [c, a, b]

    A ideia √© p√¥r o maior na base com 1 rota√ß√£o (ra ou rra) e depois, se os dois de cima estiverem desordenados, fazer 1 swap (sa).
    Com isso ficamos com a stack A ordenada, do topo para a base [menor, m√©dio, maior].
                                                                   ^topo  ^meio  ^base

    Como isto funciona sempre ? Com 3 elementos, h√° s√≥ 6 ordens poss√≠veis em que em todas elas:

        > com um rotate ou reverse rotate (ra ou rra) conseguimos colocar o maior na base.
        
              [a, b, c] ‚Üí ra ‚Üí [b, c, a]   ou   [a, b, c] ‚Üí rra ‚Üí [c, a, b]

        > se os dois de cima (o topo e o meio) estiverem desordenados (topo > meio), trocamos eles com o swap (sa).
        
    Utilizamos assim no m√°ximo duas opera√ß√µes.

    A fun√ß√£o ft_sort_three() precisa de saber onde est√° o maior dos tr√™s para decidir que rota√ß√£o fazer:

        - se o maior est√° no topo ‚Üí ra (o topo vai para a base)  ->  [a, b, c] ‚Üí ra ‚Üí [b, c, a]
        - se o maior est√° no meio ‚Üí rra (a base vai para o topo, empurrando o meio para a base)  ->  [a, b, c] ‚Üí rra ‚Üí [c, a, b]
        - se n√£o est√° no topo nem no meio, ent√£o est√° na base ‚Üí n√£o roda.
    
        - Encontramos o maior e colocamos ele na base com ra (se estava no topo) ou com rra (se estava no meio).
        - Se for necess√°rio, se os dois do topo (topo e meio) estiverem desordenados, utilizamos sa.
    
    Garante que, no fim, a stack A fica com uma base ordenada - [menor, m√©dio, maior] - pronta para receber os restantes
    elementos que est√£o na stack B.

    Sem esta fase, ao reintroduzirmos os valores na stack A exigiria reposicionar tamb√©m o ‚Äún√∫cleo‚Äù, complicando os custos e
    aumentando os movimentos.


    > Reinser√ß√£o
    
      while (*stack_b)         // enquanto houver na stack B, reintroduzimos no local certo
	  {
		ft_assign_pos(stack_a, stack_b);  // (re)calculamos a posi√ß√£o de A e B e o target para cada node de B
		ft_cost(stack_a, stack_b);    // para cada node de B, calculamos os custos cost_a / cost_b (ra/rra, rb/rrb) com sinal
		ft_cheapest(stack_a, stack_b);  // escolhemos o node com menor custo total, rodamos (rr/rrr quando d√°) e faz pa
	  }
       

    Depois de deixarmos apenas 3 elementos na stack A (e ordenarmos esses 3), ficamos com muitos elementos na stack B. 
    Agora, voltamos a inserir os elementos da stack B para a stack A um a um, sempre:

        - calculando as posi√ß√µes atuais nas stacks A e B (pos);
        - descobrindo, para cada node da stack B, onde deve entrar na stack A para manter A ordenada (target);
        - calculando quantas rota√ß√µes precisamos na stack A e na B para alinhar (cost_a, cost_b);
        - escolhendo o node com menos custo da stack B e executando as rota√ß√µes adequadas (aproveitando rr/rrr), depois pa.

    Este loop repete-se at√© a stack B ficar vazia.

    Porque recalcular sempre? Porque a cada itera√ß√£o rodamos a stack A/B e fazemos um pa. Isso muda quem √© o topo e, portanto, 
    todas as posi√ß√µes. Se pos muda, tamb√©m podem mudar o target e os custos.
    Assim, a cada itera√ß√£o, as posi√ß√µes mudam, pois rodamos/empurramos, por isso, temos de recalcular pos e target sempre.

    Vejamos como calcular a posi√ß√£o:
    
    void	ft_positon(t_stack **stack)
    {
	    t_stack	*tmp;
	    int		i;    // contador de posi√ß√£o

	    i = 0;        // come√ßamos no topo
	    tmp = *stack;  // tmp aponta para o head/topo da lista (o topo da stack)
	    while (tmp)    // vamos percorrer a lista, node a node, at√© tmp == NULL
	    {
		    tmp->pos = i;
		    tmp = tmp->next;
		    i++;
	    }
    }

    Esta fun√ß√£o serve para atribuir a cada node da stack a sua posi√ß√£o atual a partir do topo. 
    Ela percorre a lista do topo at√© √† base e atribui pos = 0, 1, 2, ..., para o head/topo, 2¬∫ node, 3¬∫ node, ..., 
    respetivamente.
    Fazemos isso separadamente para a stack A e para a stack B.
    Isto √© fundamental para os custos, pois a vari√°vel pos √© essencial para decidir como rodar:

        - Se um node est√° perto do topo (posi√ß√µes pequenas), costuma ser mais barato usar a rota√ß√£o normal (ra/rb).
        - Se est√° mais perto da base, √© mais barato usar a rota√ß√£o inversa (rra/rrb).
    
    Ou seja, isto √© crucial na fase da reinser√ß√£o: saber a posi√ß√£o pos permite calcular quantas rota√ß√µes s√£o precisas (e se √©
    melhor a rota√ß√£o normal ra/rb ou a inversa rra/rrb).
    A pos diz quantas rota√ß√µes normais (ra/rb) precisamos e por compara√ß√£o com o meio da stack, sabemos quando √© melhor fazer a 
    rota√ß√£o inversa (rra/rrb).

    
    > O que √© a vari√°vel pos? A vari√°vel pos √© a posi√ß√£o atual do node na stack, a contar a partir do topo/head:

    Topo/head ‚Üí pos = 0
     2.¬∫ node ‚Üí pos = 1
     3.¬∫ node ‚Üí pos = 2

    ‚Ä¶ e assim at√© √† base.

    A posi√ß√£o √© relativa ao estado atual da stack. Se rodarmos a stack (ra, rra, rb, rrb), as posi√ß√µes mudam.

        
    > Como a fun√ß√£o ft_position() define as posi√ß√µes (pos) ?

    Calcula pos (0 = topo, 1, 2, ‚Ä¶) para todos os nodes da stack A e da stack B.

        > tmp = *stack 

        tmp aponta para o head da lista (o topo da stack).

        Esquema inicial: *stack (topo) ‚îÄ‚îÄ‚ñ∫ [N1] ‚îÄ‚îÄ‚ñ∫ [N2] ‚îÄ‚îÄ‚ñ∫ [N3] ‚îÄ‚îÄ‚ñ∫ ... ‚îÄ‚îÄ‚ñ∫ [Nk] ‚îÄ‚îÄ‚ñ∫ NULL
                                             ^tmp

        > while (tmp) - Vamos andar pela lista, n√≥ a n√≥, at√© tmp == NULL (fim).

        Primeira itera√ß√£o: - tmp est√° no N1 (topo).
                           - tmp->pos = i; ‚Üí N1.pos = 0
                           - tmp = tmp->next; ‚Üí avan√ßa para N2
                           - i++ ‚Üí i = 1

        Segunda itera√ß√£o:  - tmp est√° no N2 (2¬∫ node).
                           - tmp->pos = i; ‚Üí N2.pos = 1
                           - tmp = tmp->next; ‚Üí avan√ßa para N3
                           - i++ ‚Üí i = 2

        Terceira itera√ß√£o: - tmp est√° no N3 (3¬∫ node).
                           - tmp->pos = i; ‚Üí N3.pos = 2
                           - tmp = tmp->next; ‚Üí avan√ßa para N4
                           - i++ ‚Üí i = 3

                    ‚Ä¶ e assim sucessivamente, at√© ao final.

        √öltima itera√ß√£o (no Nk): - tmp est√° no Nk (base/head).
                                 - tmp->pos = i; ‚Üí Nk.pos = k-1
                                 - tmp = tmp->next; ‚Üí NULL
                                 - tmp == NULL, sai do while.

        Topo ‚Üí Base
        [N1 pos=0] ‚Üí [N2 pos=1] ‚Üí [N3 pos=2] ‚Üí [N4 pos=3] ‚Üí NULL

        
    Porque isto √© indispens√°vel no push swap? 
    
        Durante a reinser√ß√£o (trazer elementos da stack B para a stack A), para cada node da stack B queremos saber: 
        
            - Quantas rota√ß√µes na stack B para coloc√°-lo no topo?
              
              Para trazer um node ao topo, sabemos exatamente quantas rota√ß√µes normais precisamos - ou seja, pos.
              Para decidir rota√ß√£o normal vs rota√ß√£o inversa, comparamos a posi√ß√£o com o meio da stack.

              ‚Üí Se pos_b for pequeno, √© barato fazer "rb" "pos_b" vezes;
              ‚Üí se pos_b for grande (mais perto do fim), √© mais barato fazer "rrb" "(size_b - pos_b)" vezes.
                Ou seja, se pos > size / 2, normalmente √© mais barato fazer rota√ß√µes inversas: size - pos.

                Ex.: topo j√° √© 0 ‚Üí 0 rota√ß√µes; se for 3 ‚Üí 3 rota√ß√µes normais.

            - Quantas rota√ß√µes na stack A para alinhar com o target (posi√ß√£o onde o node de B deve entrar)?
                
                ‚Üí Mesmo racioc√≠nio com o target e com o size_a.

                Na fun√ß√£o ft_cost(), a posi√ß√£o pos:

                    > Para B: - Se pos_b <= size_b / 2 ‚Üí cost_b = + pos_b (usamos rb).
                              - Se pos_b > size_b / 2 ‚Üí cost_b = - (size_b - pos_b) (usamos rrb).

                    > Para A (usando o target calculado para aquele node de B): - Se target <= size_a / 2 ‚Üí cost_a = + target (usamos ra).
                                                                                - Se target > size_a / 2 ‚Üí cost_a = - (size_a - target) (usamos rra).

                O sinal (+ / ‚àí) permite, depois, combinar rota√ß√µes: - mesmo sinal ‚Üí d√° para usar rr (ambos +) ou rrr (ambos ‚àí) para rodar as duas pilhas
                                                                      ao mesmo tempo, reduzindo o n√∫mero de instru√ß√µes.
        
  
    > Como a posi√ß√£o pos muda com as rota√ß√µes ?

        - Exemplo com ra (rodar A para cima, ou seja, ra move o head/topo para a base):

        Antes:   A:  [v=40 | i=7 | p=0] ‚Üí [v=10 | i=1 | p=1] ‚Üí [v=30| i=5 | p=2] ‚Üí [v=50| i=9 | p=3] ‚Üí NULL

        Com ra:  A:  [v=10 | i=1 | p=?] ‚Üí [v=30| i=5 | p=?] ‚Üí [v=50| i=9 | p=?] ‚Üí [v=40 | i=7 | p=?] ‚Üí NULL

        Recalculamos a pos: 
        
                A:  [v=10 | i=1 | p=0] ‚Üí [v=30| i=5 | p=1] ‚Üí [v=50| i=9 | p=2] ‚Üí [v=40 | i=7 | p=3] ‚Üí NULL

             
        - Exemplo com rra (rodar para baixo, ou seja, rra traz a base para o topo): 

        Antes:   A:  [v=40 | i=7 | p=0] ‚Üí [v=10 | i=1 | p=1] ‚Üí [v=30| i=5 | p=2] ‚Üí [v=50| i=9 | p=3] ‚Üí NULL

        Com rra: A:  [v=50| i=9 | p=?] ‚Üí [v=40 | i=7 | p=?] ‚Üí [v=10 | i=1 | p=?] ‚Üí [v=30| i=5 | p=?] ‚Üí NULL

        Recalculamos a pos:

             A:  [v=50| i=9 | p=0] ‚Üí [v=40 | i=7 | p=1] ‚Üí [v=10 | i=1 | p=2] ‚Üí [v=30| i=5 | p=3] ‚Üí NULL



    Vejamos como calculamos o target (posi√ß√£o na stack A onde esse node deve entrar para manter A ordenada):

    > ft_target(stack_a, tmp->index, INT_MAX, target)

    int	ft_target(t_stack **stack_a, int b_index, int target_index,
				int target_pos)
    {
	    t_stack	*tmp;

	    tmp = *stack_a;  // come√ßamos no topo da stack A
        
        // 1) Tentar encontrar o sucessor (o menor indice da stack A que seja > b_index)
        
	    while (tmp)  // vamos percorrer a stack A ...
	    {
		    if (tmp->index > b_index           // verificamos se o indice do node de A √© maior do que o indice do B (filtramos apenas quem √© maior que b_index)
                && tmp->index < target_index)  // e se √© menor do que o melhor candidato j√° visto ?  (entre os maiores, guarda o menor - o sucessor)
		    {
			    target_index = tmp->index;      // atualiza o melhor indice (novo sucessor) -> sempre que encontramos um candidato, atualizamos
			    target_pos = tmp->pos;          // e guarda a posi√ß√£o desse node na stack A
		    }
		    tmp = tmp->next;                     // avan√ßa para o pr√≥ximo node
	    }
        
	    if (target_index != INT_MAX)             // verificamos se encontrou algum sucessor
		    return (target_pos);                 // se sim, devolve a posi√ß√£o dele
            
	    tmp = *stack_a;     // recome√ßamos no topo da stack A
        
        // se n√£o h√° sucessor (b_index √© maior do que todos) inserimos antes do menor indice na stack A
	    while (tmp)             // percorremos a stack A toda outra vez 
	    {
		    if (tmp->index < target_index)   // verificamos se √© o menor indice (menor indice visto)
		    {
			    target_index = tmp->index;   // se for, atualizamos (novo menor)
			    target_pos = tmp->pos;       // guarda a posi√ß√£o do menor
		    }
		    tmp = tmp->next;                 // avan√ßamos
	    }
	    return (target_pos);                 // devolve a posi√ß√£o do menor
    }

    O que √© target? 
    
    √â a posi√ß√£o na stack A onde o node da stack B deve ser inserido para manter A ordenada, por √≠ndice (que corresponde a ordenar por valor real).

    Dado um node da stack B (com indice b_index), a fun√ß√£o ft_target() diz em que posi√ß√£o da stack A (target_pos) devemos alinhar o topo
    antes de fazermos pa, para que esse node entre no lugar certo e a stack A continue ordenada por √≠ndices (ordem circular).

    A ordem circular √© quando a stack A est√° em ordem crescente por index, mas o menor (index = 0) pode ainda n√£o estar no topo (o que 
    ser√° corrigido no fim com a fun√ß√£o ft_stack_shift).

    A fun√ß√£o ft_target() utiliza a posi√ßa√µ pos dos nodes da stack A para devolver um n√∫mero da posi√ß√£o (target_pos).
    Depois, a fun√ß√£o ft_cost() utiliza esse target_pos para calcular quantas rota√ß√µes a stack A precisa (ra/rra) para colocar esse node no topo,
    antes de fazer pa.

    > b_index: corresponde ao indice do node que est√° na stack B e que queremos colocar agora na stack A.

    > L√≥gica do ‚Äúsuccessor‚Äù: 

        - Queremos o primeiro elemento maior do que b_index, mas entre os maiores, queremos o mais pequeno (o ‚Äúsuccessor‚Äù).
        - Ou seja, dentro dos indices existentes na stack A que s√£o maiores que b_index, queremos o mais pequeno desses.
          Em termos de ordem, o sucessor √© o pr√≥ximo a seguir ao b_index.
        - A posi√ß√£o (pos) do successor ser√° o target_pos: alinhar a stack A nessa posi√ß√£o e fazer pa insere antes dele.

    > candidato: enquanto percorremos a stack A, o candidato corresponde ao melhor sucessor encontrado at√© agora.
    > target_index: corresponde ao indice do candidato atual. Come√ßa com INT_MAX ("ainda n√£o tenho nenhum").
    > target_pos: √© a posi√ß√£o (na stack A) onde o node da stack B deve cair (ou seja, a posi√ß√£o do sucessor, ou do menor, no segundo while). 
                  √â o n√∫mero que a ft_target devolve; ft_cost() usa-o para escolher ra vs rra e quantas rota√ß√µes fazer na stack A para alinhar 
                  esta posi√ß√£o no topo antes de fazer pa.

    > A ideia aqui √©: ‚Äúonde, na stack A, coloco o node da stack B para manter a ordem?‚Äù ‚Üí ‚Äúcoloco-o antes do seu successor (primeiro while)! 
      Se n√£o tem successor (√© o maior de todos), coloco-o antes do menor (segundo while)‚Äù.

    > Para um node que est√° na stack B com √≠ndice b_index, queremos saber em que posi√ß√£o de A (target_pos) ele deve entrar para manter a stack A ordenada
      por √≠ndice:

            - Se existir na stack A algu√©m com √≠ndice maior do que b_index, escolhe o menor desses (o successor) e devolve a posi√ß√£o dele.
            - Se n√£o existir (ou seja, b_index √© maior do que todos os √≠ndices atualmente na stack A), devolve a posi√ß√£o do menor √≠ndice de A 
              (ordem circular ‚Üí ‚Äúentra antes do menor‚Äù).

    A ft_target usa esse pos para devolver um n√∫mero (n√£o um ponteiro), que ft_cost converte em ra/rra.

    Como as fases se relacionam?

    Fase 1 tenta achar o successor.
    Se achar, sai imediatamente com return target_pos.
    N√£o entra na fase 2.

    S√≥ entra na fase 2 quando a fase 1 n√£o encontrou o successor (ou seja, ningu√©m na stack A tem index > b_index).
    A√≠ escolhe a posi√ß√£o do menor de A.


    1¬∫ while - encontrar o sucessor
    
    Tem como objetivo de, entres todos os nodes da stack A, filtrar os que t√™m index > b_index e, entre esses, escolher o que tem menor index.
    Porqu√™? Porque ao inserirmos antes do sucessor mant√©m a ordem.
    
    > tmp = *stack_a 

    COme√ßamos no topo/head da stack A:

    *stack_a ‚îÄ‚îÄ‚ñ∫ [A0] ‚Üí [A1] ‚Üí [A2] ‚Üí ... ‚Üí [Ak] ‚Üí NULL
                   ^
                   tmp

    - b_index vem do node da stack B que vamos inserir agora.
    - target_index come√ßa com INT_MAX: ainda n√£o temos candidato.
    - target_pos come√ßa com, p.ex: 0, vai ser atualizado quando encontrarmos um candidato.

    > while (tmp)

    Percorremos todos os nodes da stack A.

        > if (tmp->index > b_index && tmp->index < target_index) ‚Äî condi√ß√£o do ‚Äúsuccessor‚Äù

        Procuramos o primeiro √≠ndice maior do que b_index, mas o mais pequeno poss√≠vel entre os maiores.

            - tmp->index > b_index ‚Üí o candidato precisa de ser maior do que b_index (sen√£o n√£o o podemos inserir antes dele).
            - tmp->index < target_index ‚Üí e tem de ser o menor entre os maiores.
            
        > Atualiza o melhor candidato
           
          target_index = tmp->index;
		  target_pos = tmp->pos; 

        Se a condi√ß√£o passou, guardamos:

            - target_index = tmp->index (o melhor √≠ndice encontrado at√© agora),
            - target_pos = tmp->pos (a posi√ß√£o desse node na stack A).

        Aqui entra ft_position(): tmp->pos √© o valor que ft_position escreveu. Sem ele, n√£o saberiamos em que posi√ß√£o alinhar na 
        stack A.        

    > if (target_index != INT_MAX) return (target_pos);

      Se encontr√°mos pelo menos um ‚Äúmaior que b_index‚Äù, devolvemos a posi√ß√£o do menor entre eles (o ‚Äúsuccessor‚Äù).
      Isto cobre o caso normal (quando b_index n√£o √© o maior de todos), ou seja, cobre o caso de existir algu√©m na stack A com indice 
      maior do que b_index.
      Ele devolve a posi√ß√£o desse pr√≥ximo maior (√© a√≥ que queremos alinhar a stack A).


      Exemplo ‚Äî CASO NORMAL (h√° successor)

      Vamos exibir [√≠ndice | pos] (o pos veio de ft_position(&A) imediatamente antes):

      A (topo‚Üíbase): [i=3 | p=0] ‚Üí [i=8 | p=1] ‚Üí [i=12 | p=2] ‚Üí [i=20 | p=3] ‚Üí NULL

      B (node a inserir na stack A): b_index = 9

      Passagem 1 (procurar successor)

      Frame 1
      tmp = A0 ‚Üí tmp->index = 3
      Condi√ß√£o: 3 > 9? n√£o ‚Üí ignora
      tmp = tmp->next ‚Üí A1

      Frame 2
      tmp = A1 ‚Üí tmp->index = 8
      8 > 9? n√£o ‚Üí ignora
      tmp = A2

      Frame 3
      tmp = A2 ‚Üí tmp->index = 12
      12 > 9? sim e 12 < target_index (INT_MAX)? sim ‚Üí match
      Atualiza: target_index = 12, target_pos = 2
      tmp = A3

      Frame 4
      tmp = A3 ‚Üí tmp->index = 20
      20 > 9? sim mas 20 < 12? n√£o ‚Üí mant√©m (12, pos=2)
      tmp = NULL ‚Üí acabou a 1¬™ passagem.

      Como target_index != INT_MAX ‚Üí retorna target_pos = 2.
      Interpreta√ß√£o (o que fazer com 2?)

      Queres p√¥r o node de B (9) antes do 12.

      Para isso, a stack A deve ser rodada at√© que a pos 2 (onde est√° o 12) fique no topo:

        - se size_a = 4, pos 2 est√° exatamente no meio ‚Üí pode ser ra ra ou rra rra conforme estrat√©gia/custos combinados com B; ft_cost decide.

      Em paralelo, a stack B deve p√¥r esse node (b_index = 9) no topo (via rb/rrb).
      Depois pa ‚Üí 9 entra antes do 12.
      Nova A (circularmente ordenada): [ 3, 8, 9, 12, 20 ].

        Ou seja: - O que isto quer dizer? Devemos alinhar a stack A para que a posi√ß√£o 2 (onde est√° o indice 12) v√° para o topo.
                 - Em paralelo, devemos alinhar a stack B para colocar o node b_index = 9 no topo.
                 - Depois fazemos pa: o de indice 9 entra antes do de indice 12.
                 - Nova A (circularmente ordenada): [3, 8, 9, 12, 20] (o menor pode n√£o estar no topo; no fim usamos ft_stack_shift).

    
    2¬∫ while - ocorre quando n√£o encontramos o sucessor e que b_index √© maior que todos os indices atualmente na stack A.
    
    O objetivo √© inserir b_index antes do menor indice da stack A -> mant√©m a ordem circular.
        
    >  while (tmp)             // percorremos a stack A toda outra vez 
	
    Se n√£o existia nenhum √≠ndice maior (ou seja, b_index √© maior que todos na stack A).
    Para manter a ordem circular, a inser√ß√£o correta √© antes do menor √≠ndice da stack A (por isso devolvemos a posi√ß√£o do menor).
    

    EXEMPLO - N√ÉO H√Å SUCESSOR

    Vamos exibir [√≠ndice | pos] (o pos veio de ft_position(&A) imediatamente antes):

      A (topo‚Üíbase): [i=3 | p=0] ‚Üí [i=8 | p=1] ‚Üí [i=12 | p=2] ‚Üí [i=20 | p=3] ‚Üí NULL

      B (node a inserir na stack A): b_index = 9

    Passagem 1 (successor) ‚Äî n√£o encontra ningu√©m

    A0: 3 > 27? n√£o

    A1: 8 > 27? n√£o

    A2: 12 > 27? n√£o

    A3: 20 > 27? n√£o ‚Üí nenhum match.

    Passagem 2 (menor de A)

    Frame 1
    tmp = A0 ‚Üí 3 < INT_MAX? sim ‚Üí target_index = 3, target_pos = 0
    tmp = A1

    Frame 2
    8 < 3? n√£o ‚Üí mant√©m (3, pos=0)
    tmp = A2

    Frame 3
    12 < 3? n√£o
    tmp = A3

    Frame 4
    20 < 3? n√£o
    tmp = NULL ‚Üí fim

    Retorna target_pos = 0.
    
    Interpreta√ß√£o

    Insere antes do menor (idx=3, pos 0):
    Alinha a stack A para pos 0 (j√° est√° no topo neste exemplo), alinha B, pa ‚Üí a stack A fica [ 27, 3, 8, 12, 20 ] (ordem circular mantida).

    No fim do algoritmo, ft_stack_shift p√µe o 0 (menor √≠ndice) no topo, ficando [3, 8, 12, 20, 27].

    
    Agora vamos ver como entra o target na fun√ß√£o ft_assign_pos():
 
     > ft_assign_pos(a, b)

    void	ft_assign_pos(t_stack **stack_a, t_stack **stack_b)
    {
	    t_stack	*tmp;
	    int		target;

	    tmp = *stack_b;
	    target = 0;
        
	    ft_positon(stack_a);  // atualiza pos em A
	    ft_positon(stack_b);  // atualiza pos em B
	    while (tmp)
	    {
		    target = ft_target(stack_a, tmp->index, INT_MAX, target);
		    tmp->target = target;
		    tmp = tmp->next;
	    }
    }

    Para cada node da stack B, descobrimos em que posi√ß√£o da stack A esse node deve ser colocado, de forma a que a stack A
    continue ordenada (o que representa o target).
    O target √©, assim, a posi√ß√£o na stack A onde esse node deve entrar para manter A ordenada.

        - procura na stack A o primeiro √≠ndice maior do que o √≠ndice do node de B;
        - se n√£o existir (node de B √© maior que todos de A), o target √© o menor √≠ndice de A.

    Resultado: para cada node da stack B sabemos onde ele deve cair na stack A.

    Vari√°veis:

        - tmp ‚Üí percorre os n√≥s de B, um a um.
        - target ‚Üí resultado devolvido pela ft_target, que diz ‚Äúa posi√ß√£o em A onde este n√≥ de B deve entrar‚Äù.
        - pos (em cada n√≥) ‚Üí foi escrito em A e B pela ft_position e serve para saber a posi√ß√£o atual (0=topo, 1, 2, ‚Ä¶).
        - target (em cada n√≥ de B) ‚Üí ser√° preenchido aqui e indica onde esse n√≥ vai cair em A.


    > Atualiza√ß√£o das posi√ß√µes: 

    ft_position(stack_a);  // escreve pos = 0,1,2,‚Ä¶ em cada node da stack A
    ft_position(stack_b);  // escreve pos = 0,1,2,‚Ä¶ em cada node da stack B

    Stack A (topo‚Üíbase):     Stack B (topo‚Üíbase):
    
    [ idx=3 | pos=0 ]        [ idx=9 | pos=0 ]
    [ idx=12| pos=1 ]        [ idx=1 | pos=1 ]
    [ idx=20| pos=2 ]        [ idx=15| pos=2 ]

    
    > Percorre os nodes da stack B:

    tmp = *stack_b;
    while (tmp) 
    {
        target = ft_target(stack_a, tmp->index, INT_MAX, target);
        tmp->target = target;
        tmp = tmp->next;
    }

    Para cada node da stack B, chama a fun√ß√£o ft_target() e passa:

        - a stack A.
        - o indice do node da stack B que estamos (tmp->index).
        - INT_MAX (indica que n√£o temos candidato incial).
        - target (target_pos), que √© a posi√ß√£o da stack A onde esse node deve ser inserido.
        
    Armazena o target: tmp->target = target.

    
    Exemplo em execu√ß√£o

    Stack A (topo‚Üíbase):     Stack B (topo‚Üíbase):
    
    [ idx=3 | pos=0 ]        [ idx=9 | pos=0 ]
    [ idx=12| pos=1 ]        [ idx=1 | pos=1 ]
    [ idx=20| pos=2 ]        [ idx=15| pos=2 ]

    Itera√ß√£o 1: node da stack B com idx=9

    Chamada: target = ft_target(A, b_index=9, target_index=INT_MAX, target_pos=0)

    A0: 3 > 9? n√£o.
    A1: 12 > 9? sim && 12 < INT_MAX ‚Üí candidato (i = 12, pos = 1).
    A2: 20 > 9? sim && 20 < 12? n√£o ‚Üí mant√©m.

    Encontrou o sucessor = 12 (pos = 1).
    Retorna target = 1.
    ‚Üí Grava na stack B: [idx=9 | pos=0 | target=1]

    Itera√ß√£o 2: node da stack B com idx = 1

    Chamada: target = ft_target(A, b_index=1, target_index=INT_MAX, target_pos=0)

    A0: 3 > 1? sim && 3 < INT_MAX ‚Üí candidato (i = 3, pos = 0).
    A1: 12 > 1? sim && 12 < 3? n√£o.
    A2: 20 > 1? sim && 20 < 3? n√£o.

    Successor = 3 (pos = 0).
    Retorna target = 0.
    ‚Üí Grava na stack B: [idx=1 | pos=1 | target=0]
    
    Itera√ß√£o 3: node da stack B com idx = 15

    Chamada: target = ft_target(A, b_index=15, target_index=INT_MAX, target_pos=0)

    A0: 3 > 15? n√£o.
    A1: 12 > 15? n√£o.
    A2: 20 > 15? sim && 20 < INT_MAX ‚Üí candidato (i = 20, pos = 2).

    Successor = 20 (pos = 2).
    Retorna target = 2.
    ‚Üí Grava na stack B: [idx=15 | pos=2 | target=2]

    Resultado final depois de ft_assign_pos

    Agora cada n√≥ de B sabe exatamente onde deve cair em A:

    Stack B:
    
    [ idx=9  | pos=0 | target=1 ]  ‚Üí o node com indice 9 deve cair antes do node com indice 12 na stack A
    [ idx=1  | pos=1 | target=0 ]  ‚Üí o node com indce 1 deve cair antes do node com indice 3 na stack A
    [ idx=15 | pos=2 | target=2 ]  ‚Üí o node com indice 15 deve cair antes do node de indice 20 na stack A

    

    
    > ft_cost(a, b)

    void	ft_cost(t_stack **stack_a, t_stack **stack_b)
    {
	    t_stack	*b_tmp;
	    int		a_size;
	    int		b_size;

	    a_size = ft_size(*stack_a);     // tamanho atual da stack A
	    b_size = ft_size(*stack_b);     // tamanho atual da stack B
	    b_tmp = *stack_b;               // come√ßamos no head/topo da stack B
        
	    while (b_tmp)                   // percorremos a stack B
	    {
		    b_tmp->cost_b = b_tmp->pos;  // custo base: pos rota√ß√µes normais (rb)
		    if (b_tmp->pos > b_size / 2) // se estiver na metade de baixo
			    b_tmp->cost_b = (b_size - b_tmp->pos) * -1;  // o custo √© negativo e vai ser mais barato fazer rrb
                
		    b_tmp->cost_a = b_tmp->target;  // custo base: target rota√ß√µes normais (ra)
		    if (b_tmp->target > a_size / 2)  // se o alvo estiver na metade de baixo 
			    b_tmp->cost_a = (a_size - b_tmp->target) * -1;  // o custo √© negativo e vai ser mais barato fazer rra
                
		    b_tmp = b_tmp->next;    // avan√ßa para o pr√≥ximo node da stack B
	    }
    }

    COmo vimos, na fun√ß√£o ft_target(), para um node que est√° na stack B com √≠ndice b_index, queremos saber em que posi√ß√£o
    na stack A (target_pos) ele deve entrar para manter a stack A ordenada, por √≠ndice:

        - Se existir na stack A algu√©m com √≠ndice maior do que b_index, escolhe o menor desses (o successor) e devolve a posi√ß√£o dele.
        - Se n√£o existir (ou seja, b_index √© maior do que todos os √≠ndices atualmente na stack A), devolve a posi√ß√£o do menor √≠ndice de A 
          (ordem circular ‚Üí ‚Äúentra antes do menor‚Äù).

    A ft_target usa a posi√ß√£o dos nodes da stack A para devolver um n√∫mero (n√£o um ponteiro) que √© o target_pos, para que
    a fun√ß√£o ft_cost() calcule quantas rota√ß√µes a stack A precisa (ra/rra) para colocar esse node no topo, antes de fazer pa.

    Vimos que cada node tem a sua posi√ß√£o (pos) e que, na fun√ß√£o ft_assign_pos(), para cada node da stack B, sabemos o seu target (posi√ß√£o na stack A 
    onde esse node de B deve entrar).

    Para cada node da stack B sabemos o cost_a e o cost_b.

    A fun√ß√£o ft_cost() transforma a posi√ß√£o e o target em n√∫meros de rota√ß√µes com sinal:

        - cost_b: quantas rota√ß√µes na stack B para trazer o node ao topo.
        - cost_a: quantas rota√ß√µes na stack A para colocar o alvo (target) no topo.

    Durante a reinser√ß√£o (trazer elementos de volta da stack B para a stack A), para cada node da stack B queremos saber: 
        
        - Quantas rota√ß√µes na stack B para coloc√°-lo no topo?
              
          Para trazer um node ao topo, sabemos exatamente quantas rota√ß√µes normais precisamos.
          Para decidir rota√ß√£o normal vs rota√ß√£o inversa, comparamos a posi√ß√£o com o meio da stack.

          Na fun√ß√£o ft_cost(), para cada node da stack B, calculamos quantas rota√ß√µes s√£o precisas para alinhar a stack:
          
            > B (para trazer o node ao topo): 

            ‚Üí Se a posi√ß√£o do node na stack B (pos_b) estiver na metade de cima (pos_b <= size_b / 2) ‚Üí cost_b = + pos_b ,
             pelo o que √© mais barato fazer "rb", "pos_b" vezes;
            ‚Üí se a posi√ß√£o do node na stack B (pos_b) se estiver na metade de baixo (pos_b > size_b / 2) ‚Üí cost_b = - (size_b - pos_b) ,
             pelo o que √© mais barato fazer "rrb", "(size_b - pos_b)" vezes.

            Supondo que estamos a processar um node da stack B (b_tmp),

                > b_tmp->cost_b = b_tmp->pos;

                  Ideia: se trouxermos este node ao topo da stack B s√≥ com rota√ß√µes normais (rb), quantas precisamos?
                  Resposta: pos vezes.
                  Sinal positivo ‚áí usamos rb.

                > if (b_tmp->pos > b_size / 2)   ->   "A posi√ß√£o pos passou da metade ?"
                    b_tmp->cost_b = (b_size - b_tmp->pos) * -1;

                  Caso o node esteja na metade de baixo da stack B, s√£o necess√°rias b_size - pos rota√ß√µes inversas (rrb).
                  Sinal negativo => usamos rrb.
                  
            > A (para alinhar o target no topo - usamos o target calculado para aquele node da stack B, para saber em que posi√ß√£o o node de B deve entrar):

            ‚Üí Se o target do node da stack B na stack A (target) estiver na metade de cima (target <= size_a / 2) ‚Üí cost_a = + target ,
              pelo o que √© mais barato fazer "ra", "target" vezes.
            ‚Üí Se o target do node da stack B na stack A (target) estiver na metade de baixo (target > size_a / 2) ‚Üí cost_a = - (size_a - target) ,
              pelo o que √© mais barato fazer "rra", "(size_a - target)" vezes.

                > b_tmp->cost_a = b_tmp->target;

                  Ideia: para inserir o node da stack B na stack A no local certo, precisamos de alinhar a stack A para que o target (posi√ß√£o-alvo) v√° ao topo.
                  Se for s√≥ com rota√ß√µes normais (ra), precisamos de target vezes.
                  Sinal positivo ‚áí usamos ra.

                > if (b_tmp->target > a_size / 2)
                    b_tmp->cost_a = (a_size - b_tmp->target) * -1;

                  Caso o target do node da stack B na stack A esteja na metade inferior, s√£o necess√°rias (a_size - target) rota√ß√µes inversas (rra).
                  Sinal negativo ‚áí usamos rra.
              
            Ou seja, se pos > size / 2, normalmente √© mais barato fazer rota√ß√µes inversas (size - pos vezes), caso contr√°rio, se pos <= size / 2,
            √© mais barato fazer rota√ß√µes normais (pos vezes).

                Ex.: topo j√° √© 0 ‚Üí 0 rota√ß√µes; se for 3 ‚Üí 3 rota√ß√µes normais.

                O sinal (+ / -) permite, depois, combinar rota√ß√µes: - mesmo sinal ‚Üí d√° para usar rr (ambos +) ou rrr (ambos -), na fun√ß√£o ft_cheapest(),
                                                                      para rodar as duas stacks ao mesmo tempo, reduzindo o n√∫mero de instru√ß√µes.

            
            Exemplo: Estado (pos e target j√° calculados por ft_position + ft_assign_pos)

                     a_size = 7 (posi√ß√µes 0..6; metade inteira = 3)
                     b_size = 5 (posi√ß√µes 0..4; metade inteira = 2)

                     Nodes na stack B (topo‚Üíbase)
                     
                     Node	 pos em B	 target em A	               Explica√ß√£o do target
                      b0	     0	         4	        b0 deve cair antes do node que est√° na pos 4 da stack A
                      b1	     1	         0	        b1 deve cair no in√≠cio (antes do menor na stack A)
                      b2	     4	         6	        b2 deve cair antes no node que est√° na pos 6 da stack A.
                      b3	     3	         2	        node mais para baixo; alvo na metade de cima


                      Calcular cost_b (B) e cost_a (A)

                      Metades:  B: b_size / 2 = 2 ‚áí pos 0..2 ‚Äúmetade de cima‚Äù; 
                                                    pos 3..4 ‚Äúmetade de baixo‚Äù;
                                A: a_size/2 = 3 ‚áí target 0..3 ‚Äúmetade de cima‚Äù; 
                                                  target 4..6 ‚Äúmetade de baixo‚Äù;

                      Node	  pos	     Regra em B	               cost_b	    target	            Regra em A	            cost_a
                       b0	   0	  0 ‚â§ 2 ‚Üí +pos (rb 0x)	         +0	          4	        4 > 3 ‚Üí -(7-4)= -3 (rra 3x)	      -3
                       b1	   1	  1 ‚â§ 2 ‚Üí +pos (rb 1x)	         +1	          0	        0 ‚â§ 3 ‚Üí +target (ra 0x)	          +0
                       b2	   4	  4 > 2 ‚Üí -(5-4)= -1 (rrb 1x)	 -1	          6	        6 > 3 ‚Üí -(7-6)= -1 (rra 1x)	      -1
                       b3	   3	  3 > 2 ‚Üí -(5-3)= -2 (rrb 2x)	 -2	          2	        2 ‚â§ 3 ‚Üí +target (ra 2x)	          +2

    A fun√ß√£o ft_cost() preenche os campos cost_a e cost_b em cada node da stack B.
    A fun√ß√£o ft_cheapest() depois vai ler esses campos em todos os nodes da stack B e calcula abs(cost_a) + abs(cost_b) e escolhe o node com
    o menor valor.
    Em seguida chama a fun√ß√£o ft_best_move() com esses dois custos, e ele: - usa rr se cost_a > 0 && cost_b > 0;
                                                                           - usa rrr se cost_a < 0 && cost_b < 0;
                                                                           - depois completa o que faltar com ra/rra e rb/rrb;
                                                                           - e no fim faz pa.


    
    > ft_cheapest(a, b)

    void	ft_cheapest(t_stack **stack_a, t_stack **stack_b)
    {
	    t_stack	*tmp;
	    int		cheapest;   // melhor custo total visto at√© agora (soma dos absolutos)
	    int		a_cost;     // cost_a do candidato (com sinal)
	    int		b_cost;     // cost_b do candidato (com sinal)

	    a_cost = 0;         // come√ßamos com 0 pois ainda n√£o encontrarmos nenhum candidato
	    b_cost = 0;         // come√ßamos com 0 pois ainda n√£o encontrarmos nenhum candidato
        
	    if (!*stack_b)    // se a stack B est√° vazia, n√£o h√° para para reinserir na stack A
		    return ;
            
	    tmp = *stack_b;      // come√ßamos no head/topo da stack B
	    cheapest = INT_MAX;  // nenhum candidato visto at√© agora
        
	    while (tmp)          // percorre todos os nodes da stack B
	    {
		    if (ft_abs(tmp->cost_a) + ft_abs(tmp->cost_b) < cheapest)   // Para cada node de B calculamos o custo total e verificamos se √© o mais barato (o melhor visto)
		    {
			    cheapest = ft_abs(tmp->cost_b) + ft_abs(tmp->cost_a);   // se for o melhor custo total √© guardado em cheapest e torna-se o melhor visto at√© agora
			    a_cost = tmp->cost_a;                                   // guarda o cost_a com sinal em a_cost (ra vs rra)
			    b_cost = tmp->cost_b;                                   // guarda o cost_b com sinal em b_cost (rb vs rrb)
		    }
		    tmp = tmp->next;
	    }
        
	    if (cheapest != INT_MAX)  // se houve pelo menos um candidato ...
		    ft_best_move(stack_a, stack_b, a_cost, b_cost);  // executa os movimentos ideais e faz pa
	    else
		    return ;
    }

    Antes de chegarmos √Ä fun√ß√£o ft_cheapest() fizemos em cada itera√ß√£o do loop principal de reinser√ß√£o:

        - ft_position(A) e ft_position(B) ‚Üí cada node tem a sua posi√ß√£o pos atualizada.
        - ft_assign_pos(A,B) ‚Üí para cada node da stack B, foi escrito o target (posi√ß√£o na stack A onde esse node deve entrar).
        - ft_cost(A,B) ‚Üí para cada node da stack B:
        
            - cost_b: quantas rota√ß√µes (rb ou rrb) na stack B s√£o precisas para colocar esse node no topo (sinal: + ‚Üí rb, - ‚Üí rrb);
            - cost_a: quantas rota√ß√µes (ra ou rra) na stack A s√£o precisas para alinhar a posi√ß√£o target desse node no topo (sinal: + ‚Üí ra, - ‚Üí rra).

    Agora a fun√ß√£o ft_cheapest() escolhe qual o node da stack B vamos reinserir j√° na stack A, utilizando os custos calculados na ft_cost().
    Assim, o node da stack B com o custo total mais baixo vai ser o primeiro a ser reinserido na stack A.

    Depois de escolhermos o mais barato, a fun√ß√£o chama a fun√ß√£o ft_best_move() para executar as rota√ß√µes da forma mais eficiente (utilizando 
    rr/rrr quando puder) e por fim, fazer pa. 

    
    > a_cost e b_cost: guardam os custos (com sinal) do candidato vencedor. Come√ßam com 0, pois ainda n√£o h√° um candidato vencedor. 
                       Assim que o primeiro node da stack B for avaliado, estes valores ser√£o substituidos pelos custos do candidato vencedor.
                       Guardar com sinal √© crucial: o sinal define a dire√ß√£o das rota√ß√µes (normal vs inversa) e permite rr/rrr caso os sinais sejam iguais.

    > |cost_a| + |cost_b|: representa o c√°lculo do custo total.
                           Por que usamos o valor absoluto (ft_abs)? cost_a e cost_b t√™m sinal (dire√ß√£o) e magnitude (quantidade de rota√ß√µes).
                           Para comparar os candidatos, interessa-nos primeiro a quantidade de instru√ß√µes; a dire√ß√£o s√≥ importa na execu√ß√£o (para combinar rr/rrr).
                           Por isso comparamos |cost_a| + |cost_b|:

                                - |cost_a| = quantas ra/rra ser√£o necess√°rias (independente do sentido),
                                - |cost_b| = quantas rb/rrb ser√£o necess√°rias.

                           A soma dos absolutos d√°-nos o n√∫mero (aproximado) de quantos passos/instru√ß√µes no total teremos de fazer para alinhar a stack A e a stack B, antes de 
                           fazermos pa. Serve apenas para eleger o melhor node da itera√ß√£o atual.
                           Se for menor do que o melhor custo total visto at√© agora (cheapest), atualizamos o candidato vencedor:
                           
                                - cheapest recebe o novo total;
                                - copia os custos com sinal (a_cost e b_cost do candidato vencedor).
                                  O sinal √© cr√≠tico para a execu√ß√£o (decidir rr/rrr vs rota√ß√µes separadas).

    > if (cheapest != INT_MAX): Se houve pelo menos um node, chamamos a fun√ß√£o ft_best_move() para executar:
    
        - rr: se a_cost e b_cost s√£o ambos +; rrr: se s√£o ambos -;
        - completa o que faltar na stack A (ra/rra) e na stack B (rb/rrb).
        - faz pa (insere o node do candidato vencedor na stack A na posi√ß√£o correta).




    Exemplo: Imaginemos na stack B (topo‚Üíbase) com 4 nodes. Cada node j√° tem: - pos e target calculados anteriormente;
                                                                              - cost_a/cost_b calculados pela ft_cost.

    B topo
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ [N0] cost_a=+3  cost_b=+0   ‚Üí total = |+3|+|+0| = 3       ‚îÇ
    ‚îÇ [N1] cost_a=+0  cost_b=+1   ‚Üí total = |+0|+|+1| = 1   ‚òÖ   ‚îÇ  ‚Üê (menor)
    ‚îÇ [N2] cost_a=-1  cost_b=-1   ‚Üí total = |-1|+|-1| = 2       ‚îÇ
    ‚îÇ [N3] cost_a=+2  cost_b=-2   ‚Üí total = |+2|+|-2| = 4       ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    B base


    A ft_cheapest() vai percorrer nesta ordem: N0 ‚Üí N1 ‚Üí N2 ‚Üí N3.

    A cada node, compara |cost_a| + |cost_b| com cheapest, e se o custo total < cheapest, esse node torna-se o candidato vencedor
    atual e guardamos a_cost e b_cost dele (com sinal).

    Estado inicial:  
    
    cheapest = INT_MAX
    a_cost   = 0
    b_cost   = 0
    tmp ‚Üí N0

    Itera√ß√£o 1 (N0):

    total = |+3| + |+0| = 3
    3 < INT_MAX ‚Üí sim ‚Üí vencedor = N0
    cheapest = 3
    a_cost   = +3
    b_cost   = +0
    tmp->next ‚Üí N1

    Itera√ß√£o 2 (N1):

    total = |+0| + |+1| = 1
    1 < 3 ‚Üí sim ‚Üí vencedor = N1
    cheapest = 1
    a_cost   = +0
    b_cost   = +1
    tmp->next ‚Üí N2

    Itera√ß√£o 3 (N2):

    total = |-1| + |-1| = 2
    2 < 1 ‚Üí n√£o ‚Üí mant√©m N1
    tmp->next ‚Üí N3

    Itera√ß√£o 4 (N3):

    total = |+2| + |-2| = 4
    4 < 1 ‚Üí n√£o ‚Üí mant√©m N1
    tmp->next ‚Üí NULL ‚Üí fim do while

    Decis√£o final: cheapest != INT_MAX ‚Üí sim
                   chama ft_best_move(A, B, a_cost=+0, b_cost=+1)


    
    
    > ft_best_move(stack_a, stack_b, a_cost, b_cost)

    void	ft_best_move(t_stack **stack_a, t_stack **stack_b, int a_cost,
		    int b_cost)
    {
	    if (a_cost < 0 && b_cost < 0)
	    	rev_rotate_both(stack_a, stack_b, &a_cost, &b_cost);
	    else if (a_cost > 0 && b_cost > 0)
	    	rotate_both(stack_a, stack_b, &a_cost, &b_cost);
	    rotate_a(stack_a, &a_cost);
	    rotate_b(stack_b, &b_cost);
	    ft_pa(stack_a, stack_b);
    }


    > a_cost: n¬∫ de rota√ß√µes para alinhar a posi√ß√£o target na stack A no topo.
    
        > 0 ‚Üí fazer ra esse n¬∫ de vezes
        < 0 ‚Üí fazer rra -(a_cost) vezes

    > b_cost: n¬∫ de rota√ß√µes para colocar o node escolhido da stack B no topo.

        > 0 ‚Üí fazer rb esse n¬∫ de vezes
        < 0 ‚Üí fazer rrb -(b_cost) vezes

    > Os sinais importam porque permitem combinar:

        a_cost > 0 && b_cost > 0 ‚Üí usar rr (ra + rb juntos)
        a_cost < 0 && b_cost < 0 ‚Üí usar rrr (rra + rrb juntos)


    > Mesma dire√ß√£o para baixo? (a_cost < 0 e b_cost < 0) ‚Üí rev_rotate_both vai fazer rrr enquanto puder e aproximar ambos de 0.

    > Mesma dire√ß√£o para cima? (a_cost > 0 e b_cost > 0) ‚Üí rotate_both vai fazer rr enquanto puder e aproximar ambos de 0.

    Depois: - rotate_a termina o resto de a_cost (se ainda n√£o for 0): ra ou rra consoante o sinal;
            - rotate_b termina o resto de b_cost (idem com rb ou rrb);
            - Finalmente pa: traz o topo de B para o topo de A (agora no lugar certo).


    static void	rev_rotate_both(t_stack **stack_a, t_stack **stack_b, int *a_cost,
	    	int *b_cost)
    {
	    while (*a_cost < 0 && *b_cost < 0)
	    {
		    (*a_cost)++;     // incrementar um n¬∫ negativo aproxima de 0
		    (*b_cost)++;
		    ft_rrr(stack_a, stack_b);
	    }
    }

    Porque incrementa?

    Se o custo √© negativo, cada rrr consome 1 rota√ß√£o inversa simult√¢nea em A e B;
    Logo, para ‚Äúandar‚Äù o contador negativo para o zero, faz-se ++ (-3 ‚Üí -2 ‚Üí -1 ‚Üí 0).

    Exemplo com contagens:
    
    a_cost = -3, b_cost = -2

    rrr ‚Üí a_cost = -2, b_cost = -1
    rrr ‚Üí a_cost = -1, b_cost = 0
    acabaram as simult√¢neas (b chegou a 0); sai



    static void	rotate_both(t_stack **stack_a, t_stack **stack_b, int *a_cost,
	    	int *b_cost)
    {
	    while (*a_cost > 0 && *b_cost > 0)
	    {
		    (*a_cost)--;   // decrementar um n¬∫ positivo aproxima de zero
		    (*b_cost)--;
		    ft_rr(stack_a, stack_b);
	    }
    }

    Porque decrementa?

    Se o custo √© positivo, cada rr consome 1 rota√ß√£o normal simult√¢nea;
    Para ‚Äúgastar‚Äù o custo at√© 0 ‚Üí --.

    Exemplo com contagens: 

    a_cost = +2, b_cost = +4

    rr ‚Üí a_cost = +1, b_cost = +3
    rr ‚Üí a_cost = +0, b_cost = +2  (acabaram as simult√¢neas)

    Exemplos: 

    (A) Sinais iguais positivos (usa rr)

    Entrada: a_cost = +3, b_cost = +1
    
    Passo 1 (rotate_both):  rr ‚Üí a_cost = +2, b_cost = 0   (acabou a simult√¢nea)
    Passo 2 (rotate_a): ra, ra (a_cost ‚Üí 0)
    Passo 3 (rotate_b): nada (b_cost j√° √© 0)
    Passo 4 pa

    Opera√ß√µes totais: rr, ra, ra, pa

    
    (B) Sinais iguais negativos (usa rrr)

    Entrada: a_cost = -2, b_cost = -5

    Passo 1 (rev_rotate_both):  rrr ‚Üí a_cost = -1, b_cost = -4
                                rrr ‚Üí a_cost = 0, b_cost = -3
    Passo 2 (rotate_a): nada
    Passo 3 (rotate_b): rrb, rrb, rrb (b_cost ‚Üí 0)
    Passo 4 pa

    Opera√ß√µes: rrr, rrr, rrb, rrb, rrb, pa


    static void	rotate_a(t_stack **stack_a, int *cost)
    {
	    while (*cost)   // enquanto ainda houver rota√ß√µes por fazer...
	    {
		    if (*cost > 0)  // Se o custo for positivo
		    {
			    ft_ra(stack_a);  // roda a stack A para cima (o topo/head vai para a base)
			    (*cost)--;       // consome uma rota√ß√£o
		    }
		    else
		    {
			    ft_rra(stack_a);
			    (*cost)++;
		    }
	    }
    }

    t_stack **stack_a ‚Üí Aponta para a stack A (precisamos de ** porque ft_ra e ft_rra podem alterar o head, o topo da linked list).

    int *cost ‚Üí Um contador de rota√ß√µes que indica quantas opera√ß√µes ainda faltam para alinhar a posi√ß√£o do target na stack A.
    
        - Se for positivo ‚Üí faltam rota√ß√µes normais (ra).
        
          Ex: Se cost = 3, quer dizer que temos de rodar 3 vezes para cima (ra).
              A cada itera√ß√£o fazemos ra.
              Subtra√≠mos 1: 3 -> 2 -> 1 -> 0.
              QUando chega a 0, o target j√° est√° no topo.
        
        - Se for negativo ‚Üí faltam rota√ß√µes inversas (rra).
        
          Ex: Se cost = -2, quer dizer que temos de rodar 2 vezes para baixo (rra).
              A cada itera√ß√£o fazemos rra.
              Somamos 1: -2 -> -1 -> 0
              Quando chega a 0, o target j√° est√° no topo.

        - Se for 0 ‚Üí j√° est√° alinhado, n√£o h√° nada a fazer.
        

    
    Exemplo 1: cost = +2 , o que significa: 2 rota√ß√µes normais (ra) para alinhar.

    Stack Inicial: A -> [4] -> [8] -> [15] -> [23] -> [42] -> NULL

    Itera√ß√£o 1: ra ‚Üí A -> [8] -> [15] -> [23] -> [42] -> [4] -> NULL
    cost = 2 ‚Üí 1

    Itera√ß√£o 2: ra ‚Üí A -> [15] -> [23] -> [42] -> [4] -> [8] -> NULL
    cost = 1 ‚Üí 0

    
    Exemplo 2: cost = -2

    Significa: 2 rota√ß√µes inversas (rra) para alinhar.

    Stack Inicial: A -> [4] -> [8] -> [15] -> [23] -> [42] -> NULL

    Itera√ß√£o 1: rra ‚Üí A -> [42] -> [4] -> [8] -> [15] -> [23] -> NULL
    cost = -2 ‚Üí -1

    Itera√ß√£o 2: rra ‚Üí A -> [23] -> [42] -> [4] -> [8] -> [15] -> NULL
    cost = -1 ‚Üí 0

      
    static void	rotate_b(t_stack **stack_b, int *b_cost)
    {
	    while (*b_cost)
	    {
		    if (*b_cost > 0)
		    {
			    ft_rb(stack_b);
			    (*b_cost)--;
		    }
		    else
		    {
			    ft_rrb(stack_b);
			    (*b_cost)++;
		    }
	    }
    }

    A fun√ß√£o rotate_b() √© exatamente igual a rotate_a(), mas aplicada √† stack B (rb e rrb em vez de ra/rra).


    

    Exemplo 1 ‚Äî cost_a positivo (usa ra)
    
    Estado inicial (ap√≥s ft_position e ft_assign_pos)

    A (topo‚Üíbase, a_size = 5):    [i=3 | p=0] ‚Üí [i=8 | p=1] ‚Üí [i=12 | p=2 ] ‚Üí [i=20 | p=3] ‚Üí [i=27 | p=4] ‚Üí NULL
                                       A0            A1             A2              A3             A4

    B (topo‚Üíbase, b_size = 3):    [i=9 | p=0 | tg=?] ‚Üí [i=15 | p=1 | tg=?] ‚Üí [i=1 | p=2 | target=?] ‚Üí NULL
                                         B0                    B1                   B2


    Suponhamos que estamos a avaliar o node B0 (topo da stack B), com index = 9.
    A fun√ß√£o ft_target(&A, b_index=9, ...):  

    Passagem 1 (procurar successor)

      Frame 1
      tmp = A0 ‚Üí tmp->index = 3
      Condi√ß√£o: 3 > 9? n√£o ‚Üí ignora
      tmp = tmp->next ‚Üí A1

      Frame 2
      tmp = A1 ‚Üí tmp->index = 8
      8 > 9? n√£o ‚Üí ignora
      tmp = tmp->next -> A2

      Frame 3
      tmp = A2 ‚Üí tmp->index = 12
      12 > 9? sim e 12 < target_index (INT_MAX)? sim ‚Üí match
      Atualiza: target_index = 12, target_pos = 2
      tmp = tmp->next -> A3

      Frame 4
      tmp = A3 ‚Üí tmp->index = 20
      20 > 9? sim mas 20 < 12? n√£o ‚Üí mant√©m (12, pos=2)
      tmp = NULL ‚Üí acabou a 1¬™ passagem.

      Como target_index != INT_MAX ‚Üí retorna target_pos = 2.

      A fun√ß√£o ft_target() devolveu target_pos = 2 (porque o sucessor na stack A √© o 12, que est√° na posi√ß√£o 2).

      O que fazer com 2? Queremos p√¥r o node da stack B (i=9) antes do node da stack A, com i=12.
      
      Logo depois da fun√ß√£o ft_assign_pos, o node B0 fica:  B0: [i=9 | p=0 | tg=2]

    A fun√ß√£o ft_cost() calcula os custos:

        > Para cada node da stack B (aqui foquemos no B0):

            - para B: cost_b depende da pos=0 com b_size=3

            - pos <= b_size/2 ‚Üí cost_b = +pos = +0 (j√° est√° no topo de B)

        > para A: cost_a depende de target=2 com a_size=5

            - target <= a_size/2 (2 <= 2) ‚Üí cost_a = +target = +2 ‚áí vamos usar ra duas vezes

    Para o node B0: cost_b = +0  (nada em B)
                    cost_a = +2  (2x ra)

    Se o candidato vencedor da fun√ß√£o ft_cheapest() for B0, ent√£o ft_best_move() acabar√° por chamar rotate_a(A, &cost_a) com cost_a = +2.
    A fun√ß√£o rotate_a alinha a posi√ß√£o target do node B0 no topo:

    Estado anterior: stack A: [i=3 | p=0] ‚Üí [i=8 | p=1] ‚Üí [i=12 | 2] ‚Üí [i=20 | p=3] ‚Üí [i=27 | p=4] ‚Üí NULL
    cost_a = +2

    Itera√ß√£o 1 (cost_a > 0 => ra): A -> [i=8 | p=0] ‚Üí [i=12 | p=1] ‚Üí [i=20 | p=2] ‚Üí [i=27 | p=3] ‚Üí [i=3 | p=4] ‚Üí NULL
    cost_a: 2 ‚Üí 1
                                   
    Itera√ß√£o 2 (cost_a > 0 => ra): A -> [i=12 | p=0] ‚Üí [i=20 | p=1] ‚Üí [i=27 | p=2] ‚Üí [i=3 | p=3] ‚Üí [i=8 | p=4] ‚Üí NULL
    cost_a chegou a 0

    O target (posi√ß√£o 2 original, onde estava o node com indice 12) est√° agora no topo.
    Isto significa que quando fizermos pa, o node da stack B (com indice 9) cair√° antes do node com indice 12.

    Onde entra a fun√ß√£o rotate_b() ? A fun√ß√£o rotate_b() √© id√™ntico √† fun√ß√£o rotate_a(), mas trabalha na stack B com rb/rrb:

        - A fun√ß√£o coloca no topo/head da stack B o node do candidato vencedor (aquele escolhido pela fun√ß√£o ft_cheapest).
        
    Depois que as stacks A e B est√£o alinhadas (target no topo da stack A e o candidato vencedor no topo da stack B), fazemos
    pa para inserir o node no lugar certo da stack A.


    
    > ft_stack_shift(a) ‚Äî Alinhamento final (menor no topo)

    static void	ft_stack_shift(t_stack **stack_a)
    {
	    int	size;
	    int	lowest;

	    size = ft_size(*stack_a);            // n¬∫ de nodes da stack A
	    lowest = ft_lowest_idx_pos(stack_a);  // posi√ß√£o do menor indice
        
	    if (lowest > size / 2)          // verifica se a posi√ß√£o do menor indice est√° na metade de baixo
	    {
		    while (lowest < size)      
		    {
			    ft_rra(stack_a);    // faz rra at√© o menor subir ao topo
			    lowest++;
		    }
	    }
	    else                           // se a posi√ß√£o do menor indice estiver na metade de cima
	    {
		    while (lowest)
		    {
			    ft_ra(stack_a);         // faz ra at√© o menor ir para o topo
			    lowest--;
		    }
	    }
    }

    Esta √© a etapa final: a fun√ß√£o ft_stack_shift() vai garantir que a stack A fica ordenada (isto √©, com o menor √≠ndice no topo).
    At√© aqui, a stack A estava ordenada circularmente, ou seja, em ordem crescente por indice, em que o menor index (index = 0) pode
    n√£o estar no topo.

    O objetivo aqui √© colocar o node com menor indice no topo da stack A, com o minimo de rota√ß√µes.
    
    Se a posi√ß√£o do node com menor indice (lowest) estiver na segunda metade da stack, ou seja, a metade de baixo (lowest > size/2) -> √© mais barato 
    fazer rra para fazer com que esse node suba at√© ao topo. Cada rra sobe o node do fim para o topo e, na contagem, aproxima lowest de size. QUando
    lowest == size, quer dizer que subimos size - original lowest vezes - o menor ficou no topo.
    
    Caso contr√°rio, se a posi√ß√£o do node com menor indice (lowest) estiver na primeira metade da stack (metade de cima) -> √© mais barato fazer ra 
    para fazer com que esse node v√° para o topo. Cada ra desce o topo para a base, o menor sobe 1 posi√ß√£o e lowest aproxima-se de 0.
    QUando lowest == 0, quer dizer que o menor chegou ao topo.

    

    int	ft_lowest_idx_pos(t_stack **stack)
    {
	    t_stack	*tmp;
	    int		lowest_i;
	    int		lowest_p;

	    tmp = *stack;             // come√ßamos no head/topo da stack A
	    lowest_i = INT_MAX;       // ainda n√£o foi encontrado nenhum indice que seja o menor at√© agora
	    ft_positon(stack);        // atualizamos a posi√ß√£o
	    lowest_p = tmp->pos;      // iniciamos com a posi√ß√£o do topo (0)
        
	    while (tmp)               // percorremos a stack A
	    {
		    if (tmp->index < lowest_i)       // se o indice do node da stack A for o menor at√© agora
		    {
			    lowest_i = tmp->index;       // atualizamos como o menor indice encontrado at√© agora
			    lowest_p = tmp->pos;         // guardamos a posi√ß√£o dele
		    }
		    tmp = tmp->next;                 // avan√ßamos para o pr√≥ximo node
	    }
	    return (lowest_p);                    // devolve a posi√ß√£o do menor
    }

    
    
    Exemplo A ‚Äî usar ra

    A (size=5):
    
    A: [i=5 | p=0] ‚Üí [i=7 | p=1] ‚Üí [i=0 | p=2] ‚Üí [i=9 | p=3] ‚Üí [i=12 | p=4]

    lowest = 2   (menor √≠ndice=0 est√° na pos 2)
    size/2 = 4/2 = 2
    
    lowest <= size/2 ‚Üí est√° na primeira metade da stack A -> size - lowest = 4 - 2 -> usa ra (2 vezes)
    
    1¬™ itera√ß√£o: ra ‚Üí A: [i=7 | p=0] ‚Üí [i=0 | p=1] ‚Üí [i=9 | p=2] ‚Üí [i=12 | p=3] ‚Üí [i=5 | p=4]
    lowest: 2‚Üí1

    2¬™ itera√ß√£o: ra ‚Üí A: [i=0 | p=0] ‚Üí [i=9 | p=1] ‚Üí [i=12 | p=2] ‚Üí [i=5 | p=3] ‚Üí [i=7 | p=4]
    lowest: 1 -> 0

    O while parou -> o menor (lowest original p = 2, e i = 0) est√° no topo.


    Exemplo B ‚Äî usar rra

    A (size=6):

    A: [i=5 | p=0] ‚Üí [i=7 | p=1] ‚Üí [i=8 | p=2] ‚Üí [i=9 | p=3] ‚Üí [i=12 | p=4] ‚Üí [i=0 | p=5]

    lowest = 5   (menor=0 est√° na pos 5)
    size/2 = 6/2 = 3
    
    lowest > size/2 ‚Üí est√° na segunda metade da stack A -> size - lowest = 6 - 5 = 1 -> usa rra 1 vez

    1¬™ itera√ß√£o: rra ->  [i=0 | p=0] ‚Üí [i=5 | p=1] ‚Üí [i=7 | p=2] ‚Üí [i=8 | p=3] ‚Üí [i=9 | p=4] ‚Üí [i=12 | p=5]

    O while parou -> o menor (lowest original p = 5 e i = 0) est√° no topo.
























